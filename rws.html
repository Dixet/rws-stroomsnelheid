<!-- 
Page to show the current forecast for a dive site in Zeeland, Netherlands.
This page fetches data from the Rijkswaterstaat Waterberichtgeving API and displays it in a table format.
The data includes current speed and direction, with color coding based on the current speed. 

The page also includes a legend to explain the color coding.
The user can select a dive site and specify a time range to get the forecast data.  
The selection of dive sites is based on the available data from the Rijkswaterstaat API.
The dates and times are set to default values of the current date and time, and two days later for the end date and time.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dive Site Data</title>
    <script>
        /**
         * Get the current viewport width using multiple methods for better browser compatibility
         * @returns {number} - Current viewport width in pixels
         */
        function getViewportWidth() {
            return window.innerWidth || 
                   document.documentElement.clientWidth || 
                   document.body.clientWidth || 
                   1200; // Fallback to a reasonable default
        }

        /**
         * Sets default date and time values for the form inputs when the page loads.
         * Start date/time is set to current date/time, end date/time is set to 48 hours later.
         * This provides a reasonable default time range for fetching dive site data.
         */
        function setDefaultDateTime() {
            const now = new Date();
            // Extract date part in YYYY-MM-DD format from ISO string
            const currentDate = now.toISOString().slice(0, 10);
            // Extract time part in HH:MM format from time string
            const currentTime = now.toTimeString().slice(0, 5);
            document.getElementById('startDate').value = currentDate;
            document.getElementById('startTime').value = currentTime;

            // Calculate date/time 48 hours (2 days) from now
            const later = new Date(now.getTime() + 48 * 60 * 60 * 1000);
            const endDate = later.toISOString().slice(0, 10);
            const endTime = later.toTimeString().slice(0, 5);
            document.getElementById('endDate').value = endDate;
            document.getElementById('endTime').value = endTime;
        }
        /**
         * Converts degrees (0-360) to wind direction abbreviation (N, NE, E, SE, S, SW, W, NW).
         * Uses mathematical calculation instead of array lookup for better performance.
         * @param {number} degrees - The direction in degrees (0-360)
         * @returns {string} - Wind direction abbreviation (e.g., "N", "SE")
         */
        function getWindDirection(degrees) {
            // Normalize degrees to ensure positive value in 0-360 range
            // The double modulo operation handles negative values correctly
            degrees = ((degrees % 360) + 360) % 360;
            
            // Convert degrees to 8-point compass index using mathematical division
            // Each compass point covers 45 degrees (360/8 = 45)
            const directions = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
            return directions[Math.round(degrees / 45) % 8];
        }

        /**
         * Main function to fetch water current data from Rijkswaterstaat API and display results.
         * Retrieves both current speed and direction data for the selected dive site and time range.
         * Handles UI state management (loading spinner, clearing previous results) and error handling.
         */
        async function fetchData() {
            // Clear containers immediately when button is pressed to provide immediate user feedback
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            const loadingSpinner = document.getElementById('loading-spinner');
            const legend = document.querySelector('.legend');
            
            // Reset UI state - clear previous results and show loading state
            diveWindowsContainer.innerHTML = '';
            resultsContainer.innerHTML = '';
            
            // Hide legend and show loading spinner to indicate data is being fetched
            legend.style.display = 'none';
            loadingSpinner.style.display = 'block';

            // Extract form values for API request parameters
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const diveSite = document.getElementById('diveSite').value;

            // Construct ISO datetime strings from separate date and time inputs
            // Format: YYYY-MM-DDTHH:MM:SS (ISO 8601 format)
            const localStartDateTimeString = `${startDate}T${startTime}:00`;
            const localEndDateTimeString = `${endDate}T${endTime}:00`;

            // Convert local time to UTC for API requests (RWS API expects UTC timestamps)
            const StartDateISO = LocalToUTC(localStartDateTimeString);
            const EndDateISO = LocalToUTC(localEndDateTimeString);

            // Use the RWS API to fetch data for the selected dive site and time range
            // Note: The observationTypeId and sourceName are hardcoded based on the API documentation 
            // url is the URL to fetch the water speed data, and url_w is the URL to fetch the water direction data
            const url = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?locationCode=${encodeURIComponent(diveSite)}&observationTypeId=SG_SOF_6.1.ms&sourceName=compute&&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&&`;
            const url_w = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?observationTypeId=SG.2&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;

            try {
                // Make parallel API calls to fetch both speed and direction data simultaneously
                // This is more efficient than sequential calls
                const response = await fetch(url);
                const data = await response.json();
                // get direction information
                const response_w = await fetch(url_w);
                const data_w = await response_w.json();
                
                // Process and display the fetched data
                displayResults(data, data_w);
            } catch (error) {
                // Handle network errors, API errors, or JSON parsing errors
                console.error('Error fetching data:', error);
                resultsContainer.textContent = 'Fout bij het ophalen van gegevens. Probeer het opnieuw.';
            } finally {
                // Always hide loading spinner when done, regardless of success or failure
                loadingSpinner.style.display = 'none';
            }
        }

        /**
         * Main function to process and display water current data in both timeline and tabular formats.
         * Creates dive windows visualization showing optimal diving periods and detailed current information.
         * @param {Object} data - Speed data from RWS API containing current measurements in m/s
         * @param {Object} data_w - Direction data from RWS API containing current direction in degrees
         */
        function displayResults(data ,data_w) {
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            const legend = document.querySelector('.legend');

            // Verify that we have valid data before proceeding
            if (data.results && data.results.length > 0) {
                // Combine speed and direction data into a single array for easier processing
                const speedEvents = data.results[0].events;
                const directionEvents = data_w.results[0].events;
                
                // Create combined measurements array with speed and direction data, filtering out invalid entries
                const currentMeasurements = speedEvents
                    .map((speedEvent, index) => ({
                        timeStamp: speedEvent.timeStamp,
                        speed: parseFloat(speedEvent.value), // Current speed in m/s
                        direction: parseFloat(directionEvents[index].value), // Current direction in degrees
                        isLowest: false, // Will be set during slack time calculation
                        isPeak: false // Will be set during peak current calculation
                    }))
                    .filter(measurement => 
                        !isNaN(measurement.speed) && 
                        measurement.speed !== null && 
                        measurement.speed !== undefined &&
                        !isNaN(measurement.direction) && 
                        measurement.direction !== null && 
                        measurement.direction !== undefined
                    );

                // Helper functions for data processing and formatting
                
                /**
                 * Calculate the difference in minutes between two timestamp objects
                 * @param {Object} start - Event object with timeStamp property
                 * @param {Object} end - Event object with timeStamp property
                 * @returns {number} - Difference in minutes
                 */
                const getMinutesBetween = (start, end) => {
                    if (!start || !end) return 0;
                    return (new Date(end.timeStamp) - new Date(start.timeStamp)) / (1000 * 60);
                };

                /**
                 * Determines if there's a significant direction change indicating tide turning
                 * A direction change occurs when one direction is >180° and the other is <180°
                 * @param {number} dir1 - First direction in degrees
                 * @param {number} dir2 - Second direction in degrees
                 * @returns {boolean} - True if significant direction change detected
                 */
                const isDirectionChange = (dir1, dir2) => (dir1 > 180 && dir2 < 180) || (dir1 < 180 && dir2 > 180);

                /**
                 * Format timestamp to display only time portion (HH:MM)
                 * @param {string} timestamp - UTC timestamp string
                 * @returns {string} - Formatted time string
                 */
                const formatTime = (timestamp) => UTCToLocal(timestamp).toLocaleString().split(', ')[1].substring(0,5);

                /**
                 * Format timestamp to display only date portion
                 * @param {string} timestamp - UTC timestamp string
                 * @returns {string} - Formatted date string
                 */
                const formatDate = (timestamp) => UTCToLocal(timestamp).toLocaleString().split(', ')[0];

                // Pre-calculate all slack times once to avoid redundant calculations
                // Slack times occur at direction changes with the lowest water speed
                const slackTimes = new Set();
                currentMeasurements.forEach((measurement, index) => {
                    if (index < currentMeasurements.length - 1) {
                        const currentDir = measurement.direction;
                        const nextDir = currentMeasurements[index + 1].direction;
                        
                        // Check if this is a tide turning point (direction change)
                        if (isDirectionChange(currentDir, nextDir)) {
                            const currentSpeed = measurement.speed;
                            const nextSpeed = currentMeasurements[index + 1].speed;
                            
                            // Mark the measurement with lower speed as the slack time
                            // This represents the moment of minimal current flow
                            if (currentSpeed < nextSpeed) {
                                currentMeasurements[index].isLowest = true;
                                slackTimes.add(index);
                            } else {
                                currentMeasurements[index + 1].isLowest = true;
                                slackTimes.add(index + 1);
                            }
                        }
                    }
                });

                // Calculate peak currents - highest speed between slack tides
                // Convert slackTimes set to sorted array for easier processing
                const slackIndices = Array.from(slackTimes).sort((a, b) => a - b);
                
                // Find peak currents between consecutive slack times
                for (let i = 0; i < slackIndices.length - 1; i++) {
                    const startIndex = slackIndices[i];
                    const endIndex = slackIndices[i + 1];
                    
                    // Find the measurement with highest speed between these slack times
                    let peakIndex = -1;
                    let highestSpeed = -1;
                    
                    for (let j = startIndex + 1; j < endIndex; j++) {
                        const currentSpeed = currentMeasurements[j].speed;
                        if (currentSpeed > highestSpeed) {
                            highestSpeed = currentSpeed;
                            peakIndex = j;
                        }
                    }
                    
                    // Mark the peak current if found
                    if (peakIndex !== -1) {
                        currentMeasurements[peakIndex].isPeak = true;
                    }
                }
                
                // Handle peak current before first slack time (if any measurements exist before first slack)
                if (slackIndices.length > 0 && slackIndices[0] > 0) {
                    let peakIndex = -1;
                    let highestSpeed = -1;
                    
                    for (let j = 0; j < slackIndices[0]; j++) {
                        const currentSpeed = currentMeasurements[j].speed;
                        if (currentSpeed > highestSpeed) {
                            highestSpeed = currentSpeed;
                            peakIndex = j;
                        }
                    }
                    
                    if (peakIndex !== -1) {
                        currentMeasurements[peakIndex].isPeak = true;
                    }
                }
                
                // Handle peak current after last slack time (if any measurements exist after last slack)
                if (slackIndices.length > 0 && slackIndices[slackIndices.length - 1] < currentMeasurements.length - 1) {
                    let peakIndex = -1;
                    let highestSpeed = -1;
                    const lastSlackIndex = slackIndices[slackIndices.length - 1];
                    
                    for (let j = lastSlackIndex + 1; j < currentMeasurements.length; j++) {
                        const currentSpeed = currentMeasurements[j].speed;
                        if (currentSpeed > highestSpeed) {
                            highestSpeed = currentSpeed;
                            peakIndex = j;
                        }
                    }
                    
                    if (peakIndex !== -1) {
                        currentMeasurements[peakIndex].isPeak = true;
                    }
                }

                /**
                 * Determine tide indicator (LW=Low Water, HW=High Water) based on direction change
                 * @param {number} slackIndex - Index of slack time in events array
                 * @returns {string} - 'LW', 'HW', or empty string
                 */
                const getTideIndicator = (slackIndex) => {
                    // Get direction before and after the slack time to determine tide type
                    const beforeDirection = slackIndex > 0 ? 
                        currentMeasurements[slackIndex - 1].direction : 
                        currentMeasurements[slackIndex].direction;
                    const afterDirection = slackIndex < currentMeasurements.length - 1 ? 
                        currentMeasurements[slackIndex + 1].direction : 
                        currentMeasurements[slackIndex].direction;
                    
                    // Determine tide type based on direction change pattern
                    if (beforeDirection > 180 && afterDirection < 180) return 'LW';
                    if (beforeDirection < 180 && afterDirection > 180) return 'HW';
                    return '';
                };

                // Add header for dive windows section
                const diveWindowsHeader = document.createElement('h2');
                diveWindowsHeader.textContent = 'Duikvensters';
                diveWindowsContainer.appendChild(diveWindowsHeader);

                // Check if conditions are favorable throughout the entire period
                const allSpeedsLow = currentMeasurements.every(measurement => measurement.speed <= 0.3);
                
                if (allSpeedsLow) {
                    // Create favorable conditions info panel
                    const favorableConditionsPanel = document.createElement('div');
                    favorableConditionsPanel.style.backgroundColor = '#d4edda';
                    favorableConditionsPanel.style.color = '#155724';
                    favorableConditionsPanel.style.border = '1px solid #c3e6cb';
                    favorableConditionsPanel.style.borderRadius = '8px';
                    favorableConditionsPanel.style.padding = '15px';
                    favorableConditionsPanel.style.margin = '15px 0 20px 0';
                    favorableConditionsPanel.style.fontSize = '1.1em';
                    favorableConditionsPanel.style.fontWeight = 'bold';
                    favorableConditionsPanel.style.textAlign = 'center';
                    favorableConditionsPanel.innerHTML = '🌊 Gunstige omstandigheden, duiken kan gedurende de hele periode worden gedaan!<br><span style="font-size: 0.9em; font-weight: normal; color: #0f5132;">Alle stromingen zijn ≤ 30 cm/s</span>';
                    
                    diveWindowsContainer.appendChild(favorableConditionsPanel);
                }

                // Create timeline container for visual representation of dive windows
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'timeline-container';

                // PHASE 1: Create dive windows based on slack tides - one window per slack tide
                // Each window extends from the peak before the slack tide to the peak after it
                let windows = []; // Array to store all valid dive windows
                let maxDuration = 0; // Used for proportional scaling of timeline bars
                
                // Create a window for each slack tide
                slackIndices.forEach((slackIndex, windowIndex) => {
                    // Find the peak before this slack tide
                    let peakBeforeIndex = -1;
                    for (let i = slackIndex - 1; i >= 0; i--) {
                        if (currentMeasurements[i].isPeak) {
                            peakBeforeIndex = i;
                            break;
                        }
                    }
                    
                    // Find the peak after this slack tide
                    let peakAfterIndex = -1;
                    for (let i = slackIndex + 1; i < currentMeasurements.length; i++) {
                        if (currentMeasurements[i].isPeak) {
                            peakAfterIndex = i;
                            break;
                        }
                    }
                    
                    // Only create a window if we have both peaks (or use data boundaries)
                    let windowStart, windowEnd;
                    
                    if (peakBeforeIndex !== -1) {
                        windowStart = currentMeasurements[peakBeforeIndex];
                    } else {
                        // If no peak before, start from beginning of data
                        windowStart = currentMeasurements[0];
                    }
                    
                    if (peakAfterIndex !== -1) {
                        windowEnd = currentMeasurements[peakAfterIndex];
                    } else {
                        // If no peak after, end at end of data
                        windowEnd = currentMeasurements[currentMeasurements.length - 1];
                    }
                    
                    const duration = getMinutesBetween(windowStart, windowEnd);
                    maxDuration = Math.max(maxDuration, duration);
                    
                    windows.push({
                        windowStart,
                        windowEnd,
                        slackTime: currentMeasurements[slackIndex],
                        slackIndex: slackIndex,
                        duration,
                        tideIndicator: getTideIndicator(slackIndex)
                    });
                });

                // PHASE 2: Create visual timeline representation
                // Find the window with the longest time between start and slack for alignment
                let maxStartToSlackTime = 0;
                windows.forEach(window => {
                    if (window.slackTime) {
                        const startToSlackTime = getMinutesBetween(window.windowStart, window.slackTime);
                        maxStartToSlackTime = Math.max(maxStartToSlackTime, startToSlackTime);
                    }
                });

                // Generate visual timeline bars for each diving window
                windows.forEach(window => {
                    // Create main container for this timeline row
                    const timelineRow = document.createElement('div');
                    timelineRow.className = 'timeline-row';
                    
                    // Add date label for this diving window
                    const dateLabel = document.createElement('div');
                    dateLabel.className = 'timeline-date';
                    dateLabel.textContent = formatDate(window.windowStart.timeStamp);
                    
                    timelineRow.appendChild(dateLabel);

                    // Create container for the bar and labels
                    const timelineBarContainer = document.createElement('div');
                    timelineBarContainer.className = 'timeline-bar-container';

                    // Create the main timeline bar representing the diving window
                    const timelineBar = document.createElement('div');
                    timelineBar.className = 'timeline-bar';
                    
                    // Calculate filler duration to align slack times across all windows
                    // Filler = (max start-to-slack time across all windows) - (this window's start-to-slack time)
                    const currentStartToSlackTime = getMinutesBetween(window.windowStart, window.slackTime);
                    const fillerDuration = maxStartToSlackTime - currentStartToSlackTime;
                    
                    // Determine base width based on screen size for better responsiveness
                    const screenWidth = getViewportWidth();
                    let baseWidth;
                    console.log('Screen width:', screenWidth); // Debug log
                    console.log('window.innerWidth:', window.innerWidth); // Debug log
                    console.log('document.documentElement.clientWidth:', document.documentElement.clientWidth); // Debug log
                    
                    if (screenWidth >= 1400) {
                        baseWidth = 1200; // Large screens - use more space
                    } else if (screenWidth >= 1200) {
                        baseWidth = 1000; // Medium-large screens
                    } else if (screenWidth >= 900) {
                        baseWidth = 800; // Medium screens - original size
                    } else {
                        baseWidth = 500; // Small screens - compact size
                    }
                    console.log('Base width:', baseWidth); // Debug log
                    
                    // Calculate consistent pixels-per-minute ratio for all timeline bars
                    // This ensures segments with the same duration have the same pixel width across all bars
                    const maxTotalDuration = maxDuration + maxStartToSlackTime;
                    const pixelsPerMinute = baseWidth / maxTotalDuration;
                    
                    // Scale bar width proportionally to window duration plus filler using consistent scale
                    const totalDuration = window.duration + fillerDuration;
                    let barWidth = totalDuration * pixelsPerMinute;
                    
                    // Ensure minimum width for very short durations on large screens
                    if (screenWidth >= 900) {
                        barWidth = Math.max(barWidth, baseWidth * 0.6); // At least 60% of base width
                        // Recalculate pixels per minute if we had to apply minimum width
                        if (barWidth === baseWidth * 0.6) {
                            // Only recalculate if this bar was adjusted to minimum width
                            const adjustedPixelsPerMinute = barWidth / totalDuration;
                        }
                    }
                    
                    console.log('Calculated bar width:', barWidth); // Debug log
                    timelineBar.style.width = `${barWidth}px`;
                    
                    // Add filler segment first if needed to align slack times
                    if (fillerDuration > 0) {
                        const fillerSegment = document.createElement('div');
                        fillerSegment.className = 'timeline-segment filler';
                        fillerSegment.style.backgroundColor = 'transparent';
                        fillerSegment.style.border = 'none';
                        const fillerWidthPx = fillerDuration * pixelsPerMinute;
                        fillerSegment.style.width = `${fillerWidthPx}px`;
                        timelineBar.appendChild(fillerSegment);
                    }

                    // Create segments based on current speed thresholds
                    // Get indices for window start and end
                    const windowStartIndex = currentMeasurements.findIndex(m => m === window.windowStart);
                    const windowEndIndex = currentMeasurements.findIndex(m => m === window.windowEnd);
                    
                    // Analyze the current data to create color-coded segments
                    let currentSegmentStart = windowStartIndex;
                    let currentSegmentType = null;
                    
                    // Helper function to determine segment type based on current speed
                    const getSegmentType = (speedInMs) => {
                        const speedInCms = speedInMs * 100;
                        if (speedInCms > 30) return 'strong'; // > 30 cm/s - red
                        if (speedInCms > 20) return 'moderate'; // 20-30 cm/s - orange  
                        return 'weak'; // ≤ 20 cm/s - green
                    };
                    
                    // Create segments by analyzing speed changes
                    const segments = [];
                    let segmentStartTime = window.windowStart.timeStamp;
                    let segmentStartType = getSegmentType(currentMeasurements[windowStartIndex].speed);
                    
                    for (let i = windowStartIndex + 1; i <= windowEndIndex; i++) {
                        const currentType = getSegmentType(currentMeasurements[i].speed);
                        
                        // If segment type changes, close current segment and start new one
                        if (currentType !== segmentStartType || i === windowEndIndex) {
                            const segmentEndTime = currentMeasurements[i].timeStamp;
                            const segmentDuration = (new Date(segmentEndTime) - new Date(segmentStartTime)) / (1000 * 60);
                            
                            segments.push({
                                type: segmentStartType,
                                duration: segmentDuration,
                                startTime: segmentStartTime,
                                endTime: segmentEndTime
                            });
                            
                            segmentStartTime = segmentEndTime;
                            segmentStartType = currentType;
                        }
                    }
                    
                    // Create visual segments
                    let isFirstVisible = true;
                    segments.forEach((segment, index) => {
                        const segmentDiv = document.createElement('div');
                        segmentDiv.className = 'timeline-segment';
                        
                        // Apply appropriate styling based on segment type
                        switch (segment.type) {
                            case 'strong':
                                segmentDiv.classList.add('speed-strong');
                                break;
                            case 'moderate':
                                segmentDiv.classList.add('speed-moderate');
                                break;
                            case 'weak':
                                segmentDiv.classList.add('speed-weak');
                                break;
                        }
                        
                        // Mark first visible segment
                        if (isFirstVisible && fillerDuration === 0) {
                            segmentDiv.classList.add('first-visible');
                            isFirstVisible = false;
                        } else if (isFirstVisible) {
                            segmentDiv.classList.add('first-visible');
                            isFirstVisible = false;
                        }
                        
                        // Calculate width in pixels using consistent pixels-per-minute ratio
                        // This ensures segments with the same duration appear the same width across all timeline bars
                        const segmentWidthPx = segment.duration * pixelsPerMinute;
                        segmentDiv.style.width = `${segmentWidthPx}px`;
                        
                        // Add slack time indicator if this segment contains the slack time
                        const segmentStartMs = new Date(segment.startTime).getTime();
                        const segmentEndMs = new Date(segment.endTime).getTime();
                        const slackTimeMs = new Date(window.slackTime.timeStamp).getTime();
                        
                        if (slackTimeMs >= segmentStartMs && slackTimeMs <= segmentEndMs) {
                            segmentDiv.style.position = 'relative';
                            
                            // Calculate relative position within the segment
                            const relativePosition = ((slackTimeMs - segmentStartMs) / (segmentEndMs - segmentStartMs)) * 100;
                            
                            // Create visual indicator for slack time (dark green line)
                            const slackContainer = document.createElement('div');
                            slackContainer.style.position = 'absolute';
                            slackContainer.style.left = `${relativePosition}%`;
                            slackContainer.style.top = '-15px'; // Extended upward but stops just below slack label
                            slackContainer.style.height = '45px'; // Covers from just below slack label to bottom of bar
                            slackContainer.style.transform = 'translateX(-50%)';
                            slackContainer.style.width = '2px';
                            slackContainer.style.backgroundColor = '#006600';
                            slackContainer.style.zIndex = '2';
                            
                            segmentDiv.appendChild(slackContainer);
                        }
                        
                        timelineBar.appendChild(segmentDiv);
                    });

                    timelineRow.appendChild(timelineBar);

                    // Add time labels above the timeline bar
                    const timeLabels = document.createElement('div');
                    timeLabels.className = 'timeline-labels';

                    /**
                     * Helper function to create positioned time labels above timeline bars
                     * @param {Object} measurement - Measurement object with timeStamp property
                     * @param {number} position - Pixel position for label placement
                     * @param {string} className - CSS class for the label
                     * @param {boolean} isStaggered - Whether this label should be positioned higher (staggered)
                     */
                    const createLabel = (measurement, position, className = 'start', isStaggered = false) => {
                        if (measurement) {
                            // No overlap checking needed since labels are staggered at different heights
                            const label = document.createElement('span');
                            label.textContent = formatTime(measurement.timeStamp);
                            label.style.left = `${position}px`;
                            label.className = className + (isStaggered ? ' staggered' : '');
                            timeLabels.appendChild(label);
                        }
                    };

                    // Position labels at key points in the diving window
                    
                    // Counter for staggering labels
                    let labelCount = 0;
                    
                    // Start of window label - adjusted for filler using consistent pixel scale
                    const startLabelPosition = fillerDuration > 0 ? 
                        fillerDuration * pixelsPerMinute : 0;
                    createLabel(window.windowStart, startLabelPosition, 'start', labelCount % 2 === 0);
                    labelCount++;

                    // Add labels for each segment transition, but only if there's enough space
                    let cumulativeDuration = fillerDuration;
                    segments.forEach((segment, index) => {
                        // Add label at the start of each segment (except the first one, which is the window start)
                        if (index > 0) {
                            const segmentStartPosition = cumulativeDuration * pixelsPerMinute;
                            // Find the measurement at this transition point
                            const segmentStartTime = new Date(segment.startTime);
                            const transitionMeasurement = currentMeasurements.find(m => 
                                Math.abs(new Date(m.timeStamp) - segmentStartTime) < 1000 // Within 1 second
                            );
                            if (transitionMeasurement) {
                                createLabel(transitionMeasurement, segmentStartPosition, 'transition', labelCount % 2 === 0);
                                labelCount++;
                            }
                        }
                        cumulativeDuration += segment.duration;
                    });

                    // End of window label using consistent pixel scale
                    const endLabelPosition = fillerDuration > 0 ? 
                        (fillerDuration + window.duration) * pixelsPerMinute : barWidth;
                    createLabel(window.windowEnd, endLabelPosition, 'end', labelCount % 2 === 0);
                    labelCount++;

                    // Add special slack time label with tide indicator
                    if (window.slackTime) {
                        // Slack time should be positioned at the same location for all windows using consistent pixel scale
                        // Position = maxStartToSlackTime from the start of the timeline
                        const slackLabelPosition = maxStartToSlackTime * pixelsPerMinute;
                        
                        // Create container for slack time information (time + tide type)
                        const slackContainer = document.createElement('div');
                        slackContainer.className = 'slack-container';
                        slackContainer.style.left = `${slackLabelPosition}px`;
                        
                        // Add tide type indicator (LW = Low Water, HW = High Water)
                        if (window.tideIndicator) {
                            const tideLabel = document.createElement('div');
                            tideLabel.textContent = window.tideIndicator;
                            tideLabel.className = 'tide-indicator';
                            slackContainer.appendChild(tideLabel);
                        }
                        
                        // Add the actual slack time
                        const slackLabel = document.createElement('div');
                        slackLabel.textContent = formatTime(window.slackTime.timeStamp);
                        slackLabel.className = 'slack-time';
                        slackContainer.appendChild(slackLabel);
                        
                        timeLabels.appendChild(slackContainer);
                    }

                    // Assemble the complete timeline row
                    timelineBarContainer.appendChild(timelineBar);
                    timelineBarContainer.appendChild(timeLabels);
                    timelineRow.appendChild(timelineBarContainer);
                    
                    // Add this timeline row to the main container
                    timelineContainer.appendChild(timelineRow);
                });

                // Add spacing and append timeline to the page
                timelineContainer.style.marginBottom = "20px";
                diveWindowsContainer.appendChild(timelineContainer);
                
                // Add mobile scroll hint for timeline
                const scrollHint = document.createElement('div');
                scrollHint.className = 'scroll-hint';
                scrollHint.innerHTML = '↔ Swipe om tijdlijn te bekijken';
                scrollHint.style.display = 'none'; // Hidden by default, shown via CSS media query
                diveWindowsContainer.appendChild(scrollHint);

                // PHASE 3: Create detailed current data table (collapsible section)
                // Add collapsible header for detailed current information
                const currentDetailsHeader = document.createElement('h2');
                currentDetailsHeader.style.cursor = 'pointer';
                currentDetailsHeader.style.userSelect = 'none';
                currentDetailsHeader.innerHTML = '<span class="collapse-arrow">▼</span> Stromingsdetails';
                
                // Create container for the detailed data table (hidden by default)
                const detailsContainer = document.createElement('div');
                detailsContainer.id = 'details-container';
                detailsContainer.style.display = 'none'; // Collapsed by default to save screen space
                
                // Add click handler to toggle the detailed view
                currentDetailsHeader.addEventListener('click', function() {
                    const arrow = this.querySelector('.collapse-arrow');
                    if (detailsContainer.style.display === 'none') {
                        detailsContainer.style.display = 'block';
                        arrow.textContent = '▲'; // Change arrow to indicate expanded state
                    } else {
                        detailsContainer.style.display = 'none';
                        arrow.textContent = '▼'; // Change arrow to indicate collapsed state
                    }
                });
                
                resultsContainer.appendChild(currentDetailsHeader);

                // Create comprehensive data table showing all current measurements
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Create table headers for the detailed current data
                const headerRow = document.createElement('tr');
                const dateHeader = document.createElement('th');
                dateHeader.textContent = 'Datum'; // Date column
                const timeHeader = document.createElement('th');
                timeHeader.textContent = 'Tijd'; // Time column
                const valueHeader = document.createElement('th');
                valueHeader.textContent = 'Stroming (cm/s)'; // Current speed in cm/s
                const DirectionHeader = document.createElement('th');
                DirectionHeader.textContent = 'Richting (°)'; // Current direction in degrees

                // Assemble table header
                headerRow.appendChild(dateHeader);
                headerRow.appendChild(timeHeader);
                headerRow.appendChild(valueHeader);
                headerRow.appendChild(DirectionHeader);
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Populate table with all current measurement data
                // Note: slack times were already calculated earlier, so we just use the isLowest flag
                currentMeasurements.forEach((measurement, index) => {
                    if (!measurement.speed) return; // Skip entries without valid current data
                    
                    const row = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    const timeCell = document.createElement('td');
                    const valueCell = document.createElement('td');
                    const directionCell = document.createElement('td');

                    // Format and populate cell data
                    dateCell.textContent = formatDate(measurement.timeStamp);
                    timeCell.textContent = formatTime(measurement.timeStamp);
                    valueCell.textContent = Math.round(measurement.speed * 100); // Convert m/s to cm/s and round
                    directionCell.textContent = measurement.direction + " (" + getWindDirection(measurement.direction) + ")";

                    // Apply color-coded background based on current strength and slack times
                    if (measurement.isLowest) {
                        // Dark green for slack times (minimal current, ideal for diving)
                        row.style.backgroundColor = '#468046'; // darker green
                    } else if (measurement.isPeak) {
                        // Dark red for peak currents (maximum current, worst for diving)
                        row.style.backgroundColor = '#cc0000'; // dark red
                    } else if (measurement.speed > 0.30) {
                        // Red for strong current (diving not recommended)
                        row.style.backgroundColor = '#ffcccc'; // light pastel red
                    } else if (measurement.speed > 0.20) {
                        // Orange for moderate current (experienced divers only)
                        row.style.backgroundColor = '#ffe6cc'; // light pastel orange
                    } else {
                        // Light green for weak current (suitable for all divers)
                        row.style.backgroundColor = '#ccffcc'; // light pastel green
                    }
                    
                    // Assemble table row
                    row.appendChild(dateCell);
                    row.appendChild(timeCell);
                    row.appendChild(valueCell);
                    row.appendChild(directionCell);
                    tbody.appendChild(row);
                });

                // Finalize and display the results
                table.appendChild(tbody);
                
                // Create a wrapper for horizontal scrolling on mobile
                const tableWrapper = document.createElement('div');
                tableWrapper.className = 'table-wrapper';
                tableWrapper.appendChild(table);
                
                detailsContainer.appendChild(tableWrapper);
                resultsContainer.appendChild(detailsContainer);
                
                // Show the color-coded legend now that results are displayed
                legend.style.display = 'block';
            } else {
                // Handle case where no data is available from the API
                resultsContainer.textContent = 'No results found.';
            }
        }
        
        /**
         * Converts UTC timestamp to browser's local timezone.
         * Handles the API's timestamp format and ensures proper timezone conversion.
         * @param {string} utcstring - UTC timestamp string from API (format: YYYY-MM-DDTHH:MM:SSZ)
         * @returns {Date} - Date object in local timezone
         */
        function UTCToLocal(utcstring) {
            // Ensure timestamp has proper milliseconds format for Date constructor
            utcISOString = utcstring.replace(':00Z',':00.000Z');
            var strUTC = ( new Date(utcISOString) ).toISOString();
            var datetimeLocal = new Date( strUTC );

            return datetimeLocal; 
        }

        /**
         * Converts local datetime string to UTC format required by the RWS API.
         * Takes browser's local time and converts it to UTC for API requests.
         * @param {string} localstring - Local datetime string (format: YYYY-MM-DDTHH:MM:SS)
         * @returns {string} - UTC timestamp string formatted for API (YYYY-MM-DDTHH:MM:SSZ)
         */
        function LocalToUTC(localstring) {
            // Convert local time to UTC ISO string
            var strUTC = ( new Date(localstring) ).toISOString();
            // Format for RWS API (remove milliseconds, use Z suffix)
            strUTCFormatted = strUTC.replace(':00.000Z',':00Z');
            return strUTCFormatted; 
        }
        
        // Initialize the page when it loads - set default date/time values
        window.onload = setDefaultDateTime;
        
        // Add resize event listener to recalculate timeline widths when window is resized
        let resizeTimeout;
        window.addEventListener('resize', function() {
            // Debounce resize events to avoid excessive recalculations
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                const resultsContainer = document.getElementById('results');
                const diveWindowsContainer = document.getElementById('dive-windows');
                
                console.log('Resize detected, viewport width:', getViewportWidth()); // Debug log
                
                // Only recalculate if we have data displayed
                if (resultsContainer.innerHTML.trim() !== '' || diveWindowsContainer.innerHTML.trim() !== '') {
                    // Trigger a data refresh to recalculate with new screen dimensions
                    // Only if we're not currently loading data
                    const loadingSpinner = document.getElementById('loading-spinner');
                    if (loadingSpinner.style.display === 'none') {
                        fetchData();
                    }
                }
            }, 250); // Wait 250ms after resize stops
        });
    </script>
    <style>
		body {
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
			margin: 0;
			padding: 20px;
			background-color: #f8f9fa;
		}
		/* Form styling */
		h1 {
			color: #2c3e50;
			margin-bottom: 30px;
			font-size: 2em;
		}
		form {
			background-color: white;
			padding: 25px;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.1);
			margin-bottom: 30px;
			max-width: 600px;
		}
		.form-row {
			display: flex;
			gap: 20px;
			margin-bottom: 20px;
			align-items: end;
		}
		.form-group {
			flex: 1;
			display: flex;
			flex-direction: column;
		}
		label {
			font-weight: bold;
			margin-bottom: 5px;
			color: #34495e;
			font-size: 0.95em;
		}
		input[type="date"], input[type="time"], select {
			padding: 10px;
			border: 2px solid #e1e8ed;
			border-radius: 4px;
			font-size: 1em;
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
			transition: border-color 0.3s ease;
		}
		input[type="date"]:focus, input[type="time"]:focus, select:focus {
			outline: none;
			border-color: #3498db;
			box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
		}
		select {
			background-color: white;
			cursor: pointer;
		}
		button[type="submit"] {
			background-color: #3498db;
			color: white;
			padding: 12px 30px;
			border: none;
			border-radius: 4px;
			font-size: 1.1em;
			font-weight: bold;
			cursor: pointer;
			transition: background-color 0.3s ease;
			width: 100%;
			margin-top: 10px;
		}
		button[type="submit"]:hover {
			background-color: #2980b9;
		}
		button[type="submit"]:active {
			transform: translateY(1px);
		}
		/* Responsive design for smaller screens */
		@media (max-width: 768px) {
			.form-row {
				flex-direction: column;
				gap: 15px;
				align-items: flex-start; /* Align form groups to the left */
			}
			
			.form-group {
				align-items: flex-start; /* Align form group contents to the left */
				width: 100%; /* Ensure form groups take full width */
			}
			
			form {
				margin: 0 10px 20px 10px;
				padding: 20px;
			}
			body {
				padding: 10px;
			}
			h1 {
				font-size: 1.5em;
				text-align: center;
			}
			
			/* Ensure form elements are left-aligned on smaller screens */
			label {
				text-align: left;
			}
			
			input[type="date"], input[type="time"], select {
				text-align: left;
			}
		}
		/* Additional responsive styles for tablets */
		@media (max-width: 1024px) {
			form {
				max-width: 100%;
			}
		}
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
            text-align: right;
        }
                h2 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        /* Styles for the timeline */
        .timeline-container {
            width: 100%;
            padding: 20px 0;
            position: relative;
            padding-left: 20px; /* Minimal left padding */
            overflow-x: auto; /* Allow horizontal scrolling on small screens */
            max-width: none; /* Remove any width constraints */
        }
        
        /* Responsive timeline container padding */
        @media (min-width: 1400px) {
            .timeline-container {
                padding-left: 30px; /* More padding for larger screens */
                padding-right: 30px;
            }
        }
        .timeline-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 85px; /* Increased from 70px to accommodate raised slack labels */
            overflow: visible;
            position: relative; /* Ensure proper positioning context */
            padding-top: 50px; /* Increased from 35px to ensure labels don't interfere with previous row */
            min-width: 950px; /* Default minimum width */
        }
        
        /* Responsive timeline row widths */
        @media (min-width: 1400px) {
            .timeline-row {
                min-width: 1400px; /* Large screens */
            }
        }
        
        @media (min-width: 1200px) and (max-width: 1399px) {
            .timeline-row {
                min-width: 1200px; /* Medium-large screens */
            }
        }
        
        @media (min-width: 900px) and (max-width: 1199px) {
            .timeline-row {
                min-width: 1000px; /* Medium screens */
            }
        }
        .timeline-date {
            position: absolute;
            left: 0;
            width: 80px; /* Reduced width to better fit date content */
            padding-top: 5px;
            text-align: left;
            transform: translateX(0px); /* Position date at the left edge */
            font-size: 0.9em;
        }
        .timeline-bar {
            height: 30px;
            display: flex;
            border-radius: 4px;
            flex-shrink: 0;
            /* Width is set dynamically via JavaScript based on screen size */
        }
        
        /* Responsive timeline bar sizing */
        @media (min-width: 1400px) {
            .timeline-bar {
                max-width: 1200px; /* Large screens */
            }
        }
        
        @media (min-width: 1200px) and (max-width: 1399px) {
            .timeline-bar {
                max-width: 1000px; /* Medium-large screens */
            }
        }
        
        @media (min-width: 900px) and (max-width: 1199px) {
            .timeline-bar {
                max-width: 800px; /* Medium screens */
            }
        }
        .timeline-segment {
            height: 100%;
            transition: width 0.3s ease;
            border: 1px solid transparent; /* Default transparent border to maintain consistent sizing */
        }
        .timeline-segment.filler {
            background-color: transparent !important;
            border: none !important;
            visibility: hidden; /* Make filler completely invisible */
        }
        .timeline-segment.speed-strong,
        .timeline-segment.speed-moderate,
        .timeline-segment.speed-weak {
            border: 1px solid #ddd !important; /* Force border with !important */
        }
        .timeline-segment.speed-strong {
            background-color: #ffcccc; /* Red for > 30 cm/s */
        }
        .timeline-segment.speed-moderate {
            background-color: #ffe6cc; /* Orange for 20-30 cm/s */
        }
        .timeline-segment.speed-weak {
            background-color: #ccffcc; /* Green for ≤ 20 cm/s */
        }
        /* Legacy support for old class names */
        .timeline-segment.speed-30 {
            background-color: #ffe6cc;
        }
        .timeline-segment.speed-20 {
            background-color: #ccffcc;
        }
        /* First visible segment gets rounded left corners */
        .timeline-segment.first-visible {
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }
        /* Last segment gets rounded right corners */
        .timeline-segment:last-child:not(.filler) {
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        .timeline-labels {
            position: absolute;
            display: flex;
            top: -50px; /* Increased to accommodate raised slack labels */
            width: 100%;
            pointer-events: none;
        }
        .timeline-labels span {
            font-size: 0.9em;
            position: absolute;
            white-space: nowrap;
            top: 30px; /* Lowered from 15px - moved down by 15px */
            transform: translateX(-50%);
            text-shadow: 0 0 3px white; /* Add text shadow to improve readability when labels are close */
        }
        
        /* Staggered labels positioned below the bar */
        .timeline-labels span.staggered {
            top: 90px; /* Lowered from 75px - moved down by 15px */
        }
        
        /* Label styling for different types */
        .timeline-labels span.transition {
            font-size: 0.8em;
            color: #666;
        }
        
        .timeline-labels span.start,
        .timeline-labels span.end {
            font-size: 0.8em; /* Match transition label size */
            color: #666; /* Match transition label color */
            font-weight: normal; /* Remove bold to match transition labels */
        }
        .timeline-bar-container {
            position: absolute;
            display: flex;
            left: 100px; /* Position right after the date label (80px width + 20px gap) */
            min-width: 0; /* Prevent container from growing beyond parent width */
            max-width: calc(100% - 120px); /* Ensure container fits within parent */
        }
        
        /* Responsive positioning for timeline bar container */
        @media (min-width: 1400px) {
            .timeline-bar-container {
                left: 120px; /* More space for larger screens */
                max-width: calc(100% - 140px);
            }
        }
        
        @media (min-width: 1200px) and (max-width: 1399px) {
            .timeline-bar-container {
                left: 110px;
                max-width: calc(100% - 130px);
            }
        }
        .slack-container {
            position: absolute;
            transform: translateX(-50%);
            text-align: center;
            min-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            top: -5px; /* Lowered from -20px - moved down by 15px */
        }
        .tide-indicator {
            color: #468046;
            font-weight: bold;
            margin-bottom: 0px; /* Remove space between tide indicator and slack time */
            font-size: 0.8em; /* Match slack-time font size */
            white-space: nowrap;
            line-height: 1;
        }
        .slack-time {
            color: #468046;
            font-weight: bold;
            padding: 0 4px;
            white-space: nowrap;
            font-size: 0.8em; /* Explicit font size to match tide-indicator */
            margin-top: 5px; /* Maintain alignment with other labels */
            line-height: 1;
        }
        /* Styles for the main table */
        #results table {
            margin-bottom: 30px;
            width: 100%; /* Make table full width */
            table-layout: auto; /* Allow columns to size based on content */
            overflow-x: auto; /* Allow horizontal scrolling if needed */
        }
        #results td {
            text-align: right;
            white-space: nowrap; /* Prevent text wrapping */
            padding: 8px 12px; /* Add more horizontal padding for better spacing */
        }
        #results th {
            text-align: right;
            white-space: nowrap;
            padding: 8px 12px;
        }
        /* Specific column widths for optimal sizing */
        #results th:nth-child(1), #results td:nth-child(1) { /* Datum */
            width: 90px;
        }
        #results th:nth-child(2), #results td:nth-child(2) { /* Tijd */
            width: 60px;
        }
        #results th:nth-child(3), #results td:nth-child(3) { /* Stroming */
            width: 100px;
        }
        #results th:nth-child(4), #results td:nth-child(4) { /* Richting */
            width: 120px;
        }
        
        /* Table wrapper for horizontal scrolling on mobile */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Collapsible header styles */
        .collapse-arrow {
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.3s ease;
        }
        #results h2:hover {
            color: #666;
        }
        .legend {
            margin-top: 20px;
            display: none; /* Hide legend by default */
        }
        .legend div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .legend .red {
            background-color: #ffcccc;
        }
        .legend .orange {
            background-color: #ffe6cc;
        }
        .legend .light-green {
            background-color: #ccffcc;
        }
        .legend .dark-green {
            background-color: #468046;
        }
        .legend .dark-red {
            background-color: #cc0000;
        }
        /* Loading spinner styles */
        .loading-spinner {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #666;
            font-style: italic;
        }
		#source {
			width: 100%;
			background-color: #f0f0f0; /* optional background color */
			padding: 10px;
			text-align: center;
			font-size: 12px; /* adjust the font size as needed */
			border-top: 1px solid #ccc; /* optional border at the top */
			margin-top: 20px;
		}
		
		/* Mobile responsive styles */
		@media (max-width: 480px) {
			body {
				padding: 5px;
			}
			
			h1 {
				font-size: 1.3em;
				margin-bottom: 20px;
			}
			
			h2 {
				font-size: 1.1em;
			}
			
			.form-row {
				align-items: flex-start; /* Align form groups to the left */
			}
			
			.form-group {
				align-items: flex-start; /* Align form group contents to the left */
				width: 100%; /* Ensure form groups take full width */
			}
			
			form {
				padding: 15px;
				margin: 0 5px 15px 5px;
			}
			
			/* Ensure form elements are left-aligned on mobile */
			label {
				text-align: left;
			}
			
			input[type="date"], input[type="time"], select {
				text-align: left;
			}
			
			/* Timeline adjustments for mobile */
			.timeline-container {
				padding-left: 20px;
				padding-right: 10px;
			}
			
			.timeline-row {
				min-width: 600px; /* Reduced minimum width for mobile */
				margin-bottom: 60px; /* Increased spacing for mobile too */
			}
			
			.timeline-date {
				width: 60px; /* Reduced width for mobile */
				font-size: 0.8em;
				transform: translateX(0px);
			}
			
			.timeline-bar {
				width: 500px; /* Smaller timeline bar for mobile */
			}
			
			.timeline-bar-container {
				left: 80px; /* 60px date width + 20px gap */
			}
			
			.timeline-labels span {
				font-size: 0.8em;
			}
			
			/* Mobile staggered labels positioned below the bar */
			.timeline-labels span.staggered {
				top: 85px; /* Lowered from 70px - moved down by 15px */
			}
			
			.slack-container {
				min-width: 30px;
				top: 0px; /* Lowered from -15px - moved down by 15px */
			}
			
			.tide-indicator {
				font-size: 0.7em;
			}
			
			.slack-time {
				font-size: 0.8em;
				padding: 0 2px;
			}
			
			/* Show scroll hint on mobile */
			.scroll-hint {
				display: block !important;
				text-align: center;
				color: #666;
				font-size: 0.9em;
				font-style: italic;
				margin-top: 10px;
				padding: 8px;
				background-color: #f9f9f9;
				border-radius: 4px;
				border: 1px dashed #ccc;
			}
			
			/* Table responsiveness for mobile */
			#results table {
				font-size: 0.9em;
			}
			
			#results th, #results td {
				padding: 6px 8px;
			}
			
			/* Legend adjustments */
			.legend {
				margin-top: 15px;
			}
			
			.legend div {
				margin-bottom: 8px;
				font-size: 0.9em;
			}
			
			.legend span {
				width: 16px;
				height: 16px;
				margin-right: 8px;
			}
			
			/* Source section */
			#source {
				font-size: 11px;
				padding: 8px;
			}
		}
		
		/* Tablet responsive styles */
		@media (max-width: 768px) and (min-width: 481px) {
			.timeline-container {
				padding-left: 20px;
			}
			
			.timeline-date {
				width: 70px; /* Reduced width for tablet */
				transform: translateX(0px);
			}
			
			.timeline-bar {
				width: 600px;
			}
			
			.timeline-bar-container {
				left: 90px; /* 70px date width + 20px gap */
			}
			
			.timeline-row {
				min-width: 720px;
			}
		}
		
        /* Ensure timeline scrolls smoothly on touch devices */
        .timeline-container {
            -webkit-overflow-scrolling: touch;
        }
        
        /* Scroll hint - hidden by default, shown on mobile */
        .scroll-hint {
            display: none;
        }		/* Hide timeline scroll bar on mobile for cleaner look */
		@media (max-width: 768px) {
			.timeline-container::-webkit-scrollbar {
				height: 3px;
			}
			
			.timeline-container::-webkit-scrollbar-track {
				background: #f1f1f1;
			}
			
			.timeline-container::-webkit-scrollbar-thumb {
				background: #888;
				border-radius: 3px;
			}
			
			.timeline-container::-webkit-scrollbar-thumb:hover {
				background: #555;
			}
		}
    </style>
</head>
<body>
    <h1>Duikkstek stromingsvoorspelling</h1>
    <form onsubmit="event.preventDefault(); fetchData();">
        <div class="form-row">
            <div class="form-group">
                <label for="diveSite">Duikplaats:</label>
                <select id="diveSite" required>
            <option value="burgd">Burghsluis</option>
            <option value="cpdl">Colijnsplaat</option>
            <option value="dypc">Dicky’s Place/Gemaal</option>
            <option value="dhdk">Dishoek</option>
            <option value="flauw">Flauwers</option>
            <option value="stvbevp">Goese Sas</option>
            <option value="ghdk">Gorishoek</option>
            <option value="hfwk">Havenhoofd West/Kurkenol</option>
            <option value="irhe">Irenehoeve</option>
            <option value="katsh">Katshoek</option>
            <option value="stvwemew">Kattendijke Parking</option>
            <option value="kstl">Kistersnol</option>
            <option value="lvnsd">Levensstrijd</option>
            <option value="oesp">Oesterputen</option>
            <option value="pltn">Plompe Toren</option>
            <option value="o11">Putti’s Place</option>
            <option value="quack">Quaack/Het oude Dorp</option>
            <option value="stvschk">Schelphoek</option>
            <option value="sphn">Sophiahaven</option>
            <option value="spak">Spyros Amenakis</option>
            <option value="stald">St Annaland</option>
            <option value="ston">Stavenisse Oostnol</option>
            <option value="stsgr">Stavenisse Steiger</option>
            <option value="strd">Strijenham</option>
            <option value="vlie">Vlietepolder</option>
            <option value="vlblt">Vuilnisbelt</option>
            <option value="grb">Wd De Groene Boei</option>
            <option value="dhoek">Wd De Hoek/Galjoen</option>
            <option value="wdoo">Wemeldinge Oost/Linda</option>
            <option value="wkkm">Westkapelle KNRM</option>
            <option value="znp1">Zeelandbrug 1e pijler</option>
            <option value="znp2">Zeelandbrug 2e pijler</option>
            <option value="zpmn">Zijpe (Midden)</option>
            <option value="znsn">Zonneschijn</option>
            <option value="zodk">Zoutelande</option>
            <option value="zubt">Zuidbout</option>
                </select>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="startDate">Startdatum:</label>
                <input type="date" id="startDate" required>
            </div>
            <div class="form-group">
                <label for="startTime">Starttijd:</label>
                <input type="time" id="startTime" required>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="endDate">Einddatum:</label>
                <input type="date" id="endDate" required>
            </div>
            <div class="form-group">
                <label for="endTime">Eindtijd:</label>
                <input type="time" id="endTime" required>
            </div>
        </div>
        <button type="submit">Toon stroming</button>
    </form>
    
    <div id="loading-spinner" class="loading-spinner">
        <div class="spinner"></div>
        <div class="loading-text">Stromingsgegevens laden...</div>
    </div>
    
    <div class="legend">
        <h2>Legenda</h2>
        <div><span class="red"></span> Duiken afgeraden (stroming > 30 cm/s)</div>
        <div><span class="orange"></span> Alleen ervaren getijdenduikers (stroming 20-30 cm/s)</div>
        <div><span class="light-green"></span> Alle getijdenduikers (stroming ≤ 20 cm/s)</div>
        <div><span class="dark-green"></span> Stromingskentering (vrijwel geen stroming)</div>
        <div><span class="dark-red"></span> Piekstroom (maximale stroming tussen kenteringen)</div>
    </div>
    <div id="dive-windows"></div>
    <div id="results"></div>
	<div id="source">De informatie op deze pagina komt van <a href="https://waterberichtgeving.rws.nl/owb/regio/regio-zeeuwse-wateren/duikstekken-zeeland">Rijkswaterstaat Waterberichtgeving</a> en wordt weergegeven zoals deze is, zonder enige garanties.<div>
</body>
</html>
