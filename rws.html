<!-- 
Page to show the current forecast for a dive site in Zeeland, Netherlands.
This page fetches data from the Rijkswaterstaat Waterberichtgeving API and displays it in a table format.
The data includes current speed and direction, with color coding based on the current speed. 

The page also includes a legend to explain the color coding.
The user can select a dive site and specify a time range to get the forecast data.  
The selection of dive sites is based on the available data from the Rijkswaterstaat API.
The dates and times are set to default values of the current date and time, and two days later for the end date and time.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dive Site Data</title>
    <script>
        /**
         * Sets default date and time values for the form inputs when the page loads.
         * Start date/time is set to current date/time, end date/time is set to 48 hours later.
         * This provides a reasonable default time range for fetching dive site data.
         */
        function setDefaultDateTime() {
            const now = new Date();
            // Extract date part in YYYY-MM-DD format from ISO string
            const currentDate = now.toISOString().slice(0, 10);
            // Extract time part in HH:MM format from time string
            const currentTime = now.toTimeString().slice(0, 5);
            document.getElementById('startDate').value = currentDate;
            document.getElementById('startTime').value = currentTime;

            // Calculate date/time 48 hours (2 days) from now
            const later = new Date(now.getTime() + 48 * 60 * 60 * 1000);
            const endDate = later.toISOString().slice(0, 10);
            const endTime = later.toTimeString().slice(0, 5);
            document.getElementById('endDate').value = endDate;
            document.getElementById('endTime').value = endTime;
        }
        /**
         * Converts degrees (0-360) to wind direction abbreviation (N, NE, E, SE, S, SW, W, NW).
         * Uses mathematical calculation instead of array lookup for better performance.
         * @param {number} degrees - The direction in degrees (0-360)
         * @returns {string} - Wind direction abbreviation (e.g., "N", "SE")
         */
        function getWindDirection(degrees) {
            // Normalize degrees to ensure positive value in 0-360 range
            // The double modulo operation handles negative values correctly
            degrees = ((degrees % 360) + 360) % 360;
            
            // Convert degrees to 8-point compass index using mathematical division
            // Each compass point covers 45 degrees (360/8 = 45)
            const directions = ["N", "NE", "E", "SE", "S", "SW", "W", "NW"];
            return directions[Math.round(degrees / 45) % 8];
        }

        /**
         * Main function to fetch water current data from Rijkswaterstaat API and display results.
         * Retrieves both current speed and direction data for the selected dive site and time range.
         * Handles UI state management (loading spinner, clearing previous results) and error handling.
         */
        async function fetchData() {
            // Clear containers immediately when button is pressed to provide immediate user feedback
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            const loadingSpinner = document.getElementById('loading-spinner');
            const legend = document.querySelector('.legend');
            
            // Reset UI state - clear previous results and show loading state
            diveWindowsContainer.innerHTML = '';
            resultsContainer.innerHTML = '';
            
            // Hide legend and show loading spinner to indicate data is being fetched
            legend.style.display = 'none';
            loadingSpinner.style.display = 'block';

            // Extract form values for API request parameters
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const diveSite = document.getElementById('diveSite').value;

            // Construct ISO datetime strings from separate date and time inputs
            // Format: YYYY-MM-DDTHH:MM:SS (ISO 8601 format)
            const localStartDateTimeString = `${startDate}T${startTime}:00`;
            const localEndDateTimeString = `${endDate}T${endTime}:00`;

            // Convert local time to UTC for API requests (RWS API expects UTC timestamps)
            const StartDateISO = LocalToUTC(localStartDateTimeString);
            const EndDateISO = LocalToUTC(localEndDateTimeString);

            // Use the RWS API to fetch data for the selected dive site and time range
            // Note: The observationTypeId and sourceName are hardcoded based on the API documentation 
            // url is the URL to fetch the water speed data, and url_w is the URL to fetch the water direction data
            const url = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?locationCode=${encodeURIComponent(diveSite)}&observationTypeId=SG_SOF_6.1.ms&sourceName=compute&&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&&`;
            const url_w = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?observationTypeId=SG.2&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;

            try {
                // Make parallel API calls to fetch both speed and direction data simultaneously
                // This is more efficient than sequential calls
                const response = await fetch(url);
                const data = await response.json();
                // get direction information
                const response_w = await fetch(url_w);
                const data_w = await response_w.json();
                
                // Process and display the fetched data
                displayResults(data, data_w);
            } catch (error) {
                // Handle network errors, API errors, or JSON parsing errors
                console.error('Error fetching data:', error);
                resultsContainer.textContent = 'Fout bij het ophalen van gegevens. Probeer het opnieuw.';
            } finally {
                // Always hide loading spinner when done, regardless of success or failure
                loadingSpinner.style.display = 'none';
            }
        }

        /**
         * Main function to process and display water current data in both timeline and tabular formats.
         * Creates dive windows visualization showing optimal diving periods and detailed current information.
         * @param {Object} data - Speed data from RWS API containing current measurements in m/s
         * @param {Object} data_w - Direction data from RWS API containing current direction in degrees
         */
        function displayResults(data ,data_w) {
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            const legend = document.querySelector('.legend');

            // Verify that we have valid data before proceeding
            if (data.results && data.results.length > 0) {
                // events contains all water speed data in 10 minute increments 
                const events = data.results[0].events;
                // events_w contains all water direction data in 10 minute increments
                // Note: this is the same time series as events, but with different values
                const events_w = data_w.results[0].events;

                // Helper functions for data processing and formatting
                
                /**
                 * Calculate the difference in minutes between two timestamp objects
                 * @param {Object} start - Event object with timeStamp property
                 * @param {Object} end - Event object with timeStamp property
                 * @returns {number} - Difference in minutes
                 */
                const getMinutesBetween = (start, end) => {
                    if (!start || !end) return 0;
                    return (new Date(end.timeStamp) - new Date(start.timeStamp)) / (1000 * 60);
                };

                /**
                 * Determines if there's a significant direction change indicating tide turning
                 * A direction change occurs when one direction is >180° and the other is <180°
                 * @param {number} dir1 - First direction in degrees
                 * @param {number} dir2 - Second direction in degrees
                 * @returns {boolean} - True if significant direction change detected
                 */
                const isDirectionChange = (dir1, dir2) => (dir1 > 180 && dir2 < 180) || (dir1 < 180 && dir2 > 180);

                /**
                 * Format timestamp to display only time portion (HH:MM)
                 * @param {string} timestamp - UTC timestamp string
                 * @returns {string} - Formatted time string
                 */
                const formatTime = (timestamp) => UTCToLocal(timestamp).toLocaleString().split(', ')[1].substring(0,5);

                /**
                 * Format timestamp to display only date portion
                 * @param {string} timestamp - UTC timestamp string
                 * @returns {string} - Formatted date string
                 */
                const formatDate = (timestamp) => UTCToLocal(timestamp).toLocaleString().split(', ')[0];

                // Pre-calculate all slack times once to avoid redundant calculations
                // Slack times occur at direction changes with the lowest water speed
                const slackTimes = new Set();
                events.forEach((event, index) => {
                    if (index < events.length - 1) {
                        const currentDir = parseFloat(events_w[index].value);
                        const nextDir = parseFloat(events_w[index + 1].value);
                        
                        // Check if this is a tide turning point (direction change)
                        if (isDirectionChange(currentDir, nextDir)) {
                            const currentSpeed = parseFloat(events[index].value);
                            const nextSpeed = parseFloat(events[index + 1].value);
                            
                            // Mark the measurement with lower speed as the slack time
                            // This represents the moment of minimal current flow
                            if (currentSpeed < nextSpeed) {
                                events[index].isLowest = true;
                                slackTimes.add(index);
                            } else {
                                events[index + 1].isLowest = true;
                                slackTimes.add(index + 1);
                            }
                        }
                    }
                });

                /**
                 * Find the best slack time (lowest current speed) within a specific time range
                 * @param {number} startIndex - Starting index in events array
                 * @param {number} endIndex - Ending index in events array
                 * @returns {number} - Index of best slack time, or -1 if none found
                 */
                const findSlackInRange = (startIndex, endIndex) => {
                    let bestSlackIndex = -1;
                    let lowestSpeed = Infinity;
                    
                    // Search through the specified range for the lowest current speed
                    for (let i = startIndex; i < endIndex; i++) {
                        if (slackTimes.has(i)) {
                            const speed = parseFloat(events[i].value);
                            if (speed < lowestSpeed) {
                                lowestSpeed = speed;
                                bestSlackIndex = i;
                            }
                        }
                    }
                    return bestSlackIndex;
                };

                /**
                 * Determine tide indicator (LW=Low Water, HW=High Water) based on direction change
                 * @param {number} slackIndex - Index of slack time in events array
                 * @returns {string} - 'LW', 'HW', or empty string
                 */
                const getTideIndicator = (slackIndex) => {
                    // Get direction before and after the slack time to determine tide type
                    const beforeDirection = slackIndex > 0 ? 
                        parseFloat(events_w[slackIndex - 1].value) : 
                        parseFloat(events_w[slackIndex].value);
                    const afterDirection = slackIndex < events_w.length - 1 ? 
                        parseFloat(events_w[slackIndex + 1].value) : 
                        parseFloat(events_w[slackIndex].value);
                    
                    // Determine tide type based on direction change pattern
                    if (beforeDirection > 180 && afterDirection < 180) return 'LW';
                    if (beforeDirection < 180 && afterDirection > 180) return 'HW';
                    return '';
                };

                // Add header for dive windows section
                const diveWindowsHeader = document.createElement('h2');
                diveWindowsHeader.textContent = 'Duikvensters';
                diveWindowsContainer.appendChild(diveWindowsHeader);

                // Create timeline container for visual representation of dive windows
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'timeline-container';

                // PHASE 1: Analyze current data to identify suitable diving time windows
                // First pass: find all windows and determine the longest duration for scaling
                let maxDuration = 0; // Used for proportional scaling of timeline bars
                let windows = []; // Array to store all valid dive windows
                let windowStart = null; // Start of current window being analyzed
                let start20 = null; // When current drops to ≤20 cm/s (good for all divers)
                let end20 = null; // When current rises above 20 cm/s
                let end30 = null; // End of window (current > 30 cm/s)
                let prevValue = null; // Previous current measurement for comparison

                events.forEach((event, index) => {
                    // Convert from m/s to cm/s for easier threshold comparisons
                    const value = parseFloat(event.value) * 100; // Convert to cm/s
                    
                    if (prevValue !== null) {
                        // Detect start of diving window (current drops to acceptable levels)
                        // 30 cm/s is the threshold - above this, diving is not recommended
                        if (prevValue > 30 && value <= 30) {
                            windowStart = event;
                        }
                        // Detect when current becomes ideal for all divers (≤20 cm/s)
                        if (prevValue > 20 && value <= 20) {
                            start20 = event;
                        }
                        // Detect when current becomes challenging again (>20 cm/s)
                        if (prevValue <= 20 && value > 20) {
                            end20 = events[index - 1];
                        }
                        // Detect end of diving window (current becomes too strong)
                        if (prevValue <= 30 && value > 30) {
                            end30 = events[index - 1];
                            
                            // If we have a complete window, validate it as a proper tide window
                            if (windowStart) {
                                const windowStartIndex = events.findIndex(e => e === windowStart);
                                const windowEndIndex = events.findIndex(e => e === end30);
                                
                                if (windowStartIndex !== -1 && windowEndIndex !== -1) {
                                    const startDirection = parseFloat(events_w[windowStartIndex].value);
                                    const endDirection = parseFloat(events_w[windowEndIndex].value);
                                    
                                    // Only store the window if there's a direction change (indicating tide change)
                                    // This ensures we're showing actual tidal windows, not just random low-current periods
                                    if ((startDirection > 180 && endDirection < 180) || 
                                        (startDirection < 180 && endDirection > 180)) {
                                        const duration = getMinutesBetween(windowStart, end30);
                                        maxDuration = Math.max(maxDuration, duration);
                                        windows.push({
                                            windowStart,
                                            start20,
                                            end20,
                                            end30,
                                            duration
                                        });
                                    }
                                }
                            }
                            
                            // Reset variables for detecting the next window
                            windowStart = null;
                            start20 = null;
                            end20 = null;
                            end30 = null;
                        }
                    }
                    prevValue = value;
                });

                // PHASE 2: Calculate slack times for each identified diving window
                // Calculate each window's slack time position for timeline alignment
                windows.forEach(window => {
                    if (window.start20 && window.end20) {
                        // Find array indices corresponding to the ≤20 cm/s period
                        const start20Index = events.findIndex(e => e === window.start20);
                        const end20Index = events.findIndex(e => e === window.end20);
                        
                        // Find the best slack time within the optimal diving period
                        const bestSlackIndex = findSlackInRange(start20Index, end20Index);
                        
                        if (bestSlackIndex !== -1) {
                            // Store slack time information for timeline positioning and labeling
                            window.slackTime = events[bestSlackIndex];
                            window.slackTimeFromStart = getMinutesBetween(window.windowStart, events[bestSlackIndex]);
                            window.tideIndicator = getTideIndicator(bestSlackIndex);
                        }
                    }
                });

                // PHASE 3: Create visual timeline representation
                // Calculate slack times and find the maximum offset needed for timeline alignment
                let referencePoint = 400; // Center point for alignment (half of 800px max width)
                
                // Second pass: create timeline rows with bars scaled to maxDuration
                // Generate visual timeline bars for each diving window
                windows.forEach(window => {
                    // Create main container for this timeline row
                    const timelineRow = document.createElement('div');
                    timelineRow.className = 'timeline-row';
                    
                    // Add date label for this diving window
                    const dateLabel = document.createElement('div');
                    dateLabel.className = 'timeline-date';
                    dateLabel.textContent = formatDate(window.windowStart.timeStamp);
                    
                    timelineRow.appendChild(dateLabel);

                    // Create container for the bar and labels
                    const timelineBarContainer = document.createElement('div');
                    timelineBarContainer.className = 'timeline-bar-container';

                    // Create the main timeline bar representing the diving window
                    const timelineBar = document.createElement('div');
                    timelineBar.className = 'timeline-bar';
                    // Scale bar width proportionally to window duration (max 800px)
                    const barWidth = Math.min((window.duration / maxDuration) * 800, 800);
                    timelineBar.style.width = `${barWidth}px`;
                    
                    // Position the bar so its slack time aligns with other windows
                    // This creates a vertical alignment of all slack times for easy comparison
                    if (window.slackTime) {
                        const slackPosition = (window.slackTimeFromStart / window.duration) * barWidth;
                        const leftOffset = referencePoint - slackPosition;
                        timelineBarContainer.style.marginLeft = `${leftOffset}px`;
                    }

                    // Create color-coded segments representing different current strength periods
                    if (window.start20) {
                        // First segment: moderate current (20-30 cm/s) - orange/yellow zone
                        const segment1 = document.createElement('div');
                        segment1.className = 'timeline-segment speed-30';
                        const width1 = (getMinutesBetween(window.windowStart, window.start20) / window.duration) * 100;
                        segment1.style.width = `${width1}%`;
                        timelineBar.appendChild(segment1);

                        if (window.end20) {
                            // Middle segment: low current (≤20 cm/s) - green zone (best for diving)
                            const segment2 = document.createElement('div');
                            segment2.className = 'timeline-segment speed-20';
                            const width2 = (getMinutesBetween(window.start20, window.end20) / window.duration) * 100;
                            segment2.style.width = `${width2}%`;
                            segment2.style.position = 'relative'; // For absolute positioning of slack indicator
                            
                            // Find and mark slack tide moment within the optimal diving period
                            const start20Index = events.findIndex(e => e === window.start20);
                            const end20Index = events.findIndex(e => e === window.end20);
                            if (start20Index !== -1 && end20Index !== -1) {
                                const bestSlackIndex = findSlackInRange(start20Index, end20Index);

                                if (bestSlackIndex !== -1) {
                                    const slackTime = events[bestSlackIndex];
                                    
                                    // Calculate the relative position of slack time within the green segment
                                    const slackTimeOffset = (getMinutesBetween(window.start20, slackTime) / getMinutesBetween(window.start20, window.end20)) * 100;
                                    
                                    // Create visual indicator for slack time (dark green line)
                                    const slackContainer = document.createElement('div');
                                    slackContainer.style.position = 'absolute';
                                    slackContainer.style.left = `${slackTimeOffset}%`;
                                    slackContainer.style.top = '0';
                                    slackContainer.style.height = '100%';
                                    slackContainer.style.transform = 'translateX(-50%)';
                                    slackContainer.style.width = '2px';
                                    slackContainer.style.backgroundColor = '#006600';
                                    slackContainer.style.zIndex = '2';

                                    // Store information for label creation below the timeline
                                    window.slackTime = slackTime;
                                    window.slackTimeFromStart = getMinutesBetween(window.windowStart, slackTime);
                                    window.tideIndicator = getTideIndicator(bestSlackIndex);
                                    
                                    // Add the slack indicator to the segment
                                    segment2.appendChild(slackContainer);
                                }
                            }
                            
                            timelineBar.appendChild(segment2);

                            // Last segment: moderate current returning (20-30 cm/s) - orange/yellow zone
                            const segment3 = document.createElement('div');
                            segment3.className = 'timeline-segment speed-30';
                            const width3 = (getMinutesBetween(window.end20, window.end30) / window.duration) * 100;
                            segment3.style.width = `${width3}%`;
                            timelineBar.appendChild(segment3);
                        } else {
                            // Special case: window ends while still in optimal diving conditions
                            const segment2 = document.createElement('div');
                            segment2.className = 'timeline-segment speed-20';
                            const width2 = (getMinutesBetween(window.start20, window.end30) / window.duration) * 100;
                            segment2.style.width = `${width2}%`;
                            timelineBar.appendChild(segment2);
                        }
                    } else {
                        // Special case: entire window is moderate current (never reaches optimal ≤20 cm/s)
                        const segment = document.createElement('div');
                        segment.className = 'timeline-segment speed-30';
                        segment.style.width = '100%';
                        timelineBar.appendChild(segment);
                    }

                    timelineRow.appendChild(timelineBar);

                    // Add time labels above the timeline bar
                    const timeLabels = document.createElement('div');
                    timeLabels.className = 'timeline-labels';

                    /**
                     * Helper function to create positioned time labels above timeline bars
                     * @param {Object} evt - Event object with timeStamp property
                     * @param {number} position - Pixel position for label placement
                     */
                    const createLabel = (evt, position) => {
                        if (evt) {
                            const label = document.createElement('span');
                            label.textContent = formatTime(evt.timeStamp);
                            label.style.left = `${position}px`;
                            label.className = 'start';
                            timeLabels.appendChild(label);
                        }
                    };

                    // Position labels at key transition points in the diving window
                    
                    // Start of window label (current drops to ≤30 cm/s)
                    createLabel(window.windowStart, 0);

                    if (window.start20) {
                        // Label when optimal conditions begin (≤20 cm/s)
                        const start20Pixels = (getMinutesBetween(window.windowStart, window.start20) / window.duration) * barWidth;
                        createLabel(window.start20, start20Pixels);

                        if (window.end20) {
                            // Label when optimal conditions end (>20 cm/s)
                            const end20Pixels = (getMinutesBetween(window.windowStart, window.end20) / window.duration) * barWidth;
                            createLabel(window.end20, end20Pixels);
                        }
                    }

                    // End of window label (current rises above 30 cm/s)
                    createLabel(window.end30, barWidth);

                    // Add special slack time label with tide indicator if available
                    if (window.slackTime) {
                        const slackLabelPosition = (window.slackTimeFromStart / window.duration) * barWidth;
                        
                        // Create container for slack time information (time + tide type)
                        const slackContainer = document.createElement('div');
                        slackContainer.className = 'slack-container';
                        slackContainer.style.left = `${slackLabelPosition}px`;
                        
                        // Add tide type indicator (LW = Low Water, HW = High Water)
                        if (window.tideIndicator) {
                            const tideLabel = document.createElement('div');
                            tideLabel.textContent = window.tideIndicator;
                            tideLabel.className = 'tide-indicator';
                            slackContainer.appendChild(tideLabel);
                        }
                        
                        // Add the actual slack time
                        const slackLabel = document.createElement('div');
                        slackLabel.textContent = formatTime(window.slackTime.timeStamp);
                        slackLabel.className = 'slack-time';
                        slackContainer.appendChild(slackLabel);
                        
                        timeLabels.appendChild(slackContainer);
                        
                        // Clean up temporary properties used for timeline generation
                        delete window.slackTime;
                        delete window.slackTimeFromStart;
                        delete window.tideIndicator;
                    }

                    // Assemble the complete timeline row
                    timelineBarContainer.appendChild(timelineBar);
                    timelineBarContainer.appendChild(timeLabels);
                    timelineRow.appendChild(timelineBarContainer);
                    
                    // Add this timeline row to the main container
                    timelineContainer.appendChild(timelineRow);
                });

                // Add spacing and append timeline to the page
                timelineContainer.style.marginBottom = "20px";
                diveWindowsContainer.appendChild(timelineContainer);

                // PHASE 4: Create detailed current data table (collapsible section)
                // Add collapsible header for detailed current information
                const currentDetailsHeader = document.createElement('h2');
                currentDetailsHeader.style.cursor = 'pointer';
                currentDetailsHeader.style.userSelect = 'none';
                currentDetailsHeader.innerHTML = '<span class="collapse-arrow">▼</span> Stromingsdetails';
                
                // Create container for the detailed data table (hidden by default)
                const detailsContainer = document.createElement('div');
                detailsContainer.id = 'details-container';
                detailsContainer.style.display = 'none'; // Collapsed by default to save screen space
                
                // Add click handler to toggle the detailed view
                currentDetailsHeader.addEventListener('click', function() {
                    const arrow = this.querySelector('.collapse-arrow');
                    if (detailsContainer.style.display === 'none') {
                        detailsContainer.style.display = 'block';
                        arrow.textContent = '▲'; // Change arrow to indicate expanded state
                    } else {
                        detailsContainer.style.display = 'none';
                        arrow.textContent = '▼'; // Change arrow to indicate collapsed state
                    }
                });
                
                resultsContainer.appendChild(currentDetailsHeader);

                // Create comprehensive data table showing all current measurements
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Create table headers for the detailed current data
                const headerRow = document.createElement('tr');
                const dateHeader = document.createElement('th');
                dateHeader.textContent = 'Datum'; // Date column
                const timeHeader = document.createElement('th');
                timeHeader.textContent = 'Tijd'; // Time column
                const valueHeader = document.createElement('th');
                valueHeader.textContent = 'Stroming (cm/s)'; // Current speed in cm/s
                const DirectionHeader = document.createElement('th');
                DirectionHeader.textContent = 'Richting (°)'; // Current direction in degrees

                // Assemble table header
                headerRow.appendChild(dateHeader);
                headerRow.appendChild(timeHeader);
                headerRow.appendChild(valueHeader);
                headerRow.appendChild(DirectionHeader);
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Populate table with all current measurement data
                // Note: slack times were already calculated earlier, so we just use the isLowest flag
                events.forEach((event, index) => {
                    if (!event.value) return; // Skip entries without valid current data
                    
                    const row = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    const timeCell = document.createElement('td');
                    const valueCell = document.createElement('td');
                    const directionCell = document.createElement('td');

                    // Format and populate cell data
                    dateCell.textContent = formatDate(event.timeStamp);
                    timeCell.textContent = formatTime(event.timeStamp);
                    valueCell.textContent = Math.round(event.value * 100); // Convert m/s to cm/s and round
                    directionCell.textContent = events_w[index].value + " (" + getWindDirection(events_w[index].value) + ")";

                    // Apply color-coded background based on current strength and slack times
                    const value = parseFloat(event.value);
                    if (event.isLowest) {
                        // Dark green for slack times (minimal current, ideal for diving)
                        row.style.backgroundColor = '#468046'; // darker green
                    } else if (value > 0.30) {
                        // Red for strong current (diving not recommended)
                        row.style.backgroundColor = '#ffcccc'; // light pastel red
                    } else if (value > 0.20) {
                        // Orange for moderate current (experienced divers only)
                        row.style.backgroundColor = '#ffe6cc'; // light pastel orange
                    } else {
                        // Light green for weak current (suitable for all divers)
                        row.style.backgroundColor = '#ccffcc'; // light pastel green
                    }
                    
                    // Assemble table row
                    row.appendChild(dateCell);
                    row.appendChild(timeCell);
                    row.appendChild(valueCell);
                    row.appendChild(directionCell);
                    tbody.appendChild(row);
                });

                // Finalize and display the results
                table.appendChild(tbody);
                detailsContainer.appendChild(table);
                resultsContainer.appendChild(detailsContainer);
                
                // Show the color-coded legend now that results are displayed
                legend.style.display = 'block';
            } else {
                // Handle case where no data is available from the API
                resultsContainer.textContent = 'No results found.';
            }
        }
        
        /**
         * Converts UTC timestamp to browser's local timezone.
         * Handles the API's timestamp format and ensures proper timezone conversion.
         * @param {string} utcstring - UTC timestamp string from API (format: YYYY-MM-DDTHH:MM:SSZ)
         * @returns {Date} - Date object in local timezone
         */
        function UTCToLocal(utcstring) {
            // Ensure timestamp has proper milliseconds format for Date constructor
            utcISOString = utcstring.replace(':00Z',':00.000Z');
            var strUTC = ( new Date(utcISOString) ).toISOString();
            var datetimeLocal = new Date( strUTC );

            return datetimeLocal; 
        }

        /**
         * Converts local datetime string to UTC format required by the RWS API.
         * Takes browser's local time and converts it to UTC for API requests.
         * @param {string} localstring - Local datetime string (format: YYYY-MM-DDTHH:MM:SS)
         * @returns {string} - UTC timestamp string formatted for API (YYYY-MM-DDTHH:MM:SSZ)
         */
        function LocalToUTC(localstring) {
            // Convert local time to UTC ISO string
            var strUTC = ( new Date(localstring) ).toISOString();
            // Format for RWS API (remove milliseconds, use Z suffix)
            strUTCFormatted = strUTC.replace(':00.000Z',':00Z');
            return strUTCFormatted; 
        }
        
        // Initialize the page when it loads - set default date/time values
        window.onload = setDefaultDateTime;
    </script>
    <style>
		body {
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
			margin: 0;
			padding: 20px;
			background-color: #f8f9fa;
		}
		/* Form styling */
		h1 {
			color: #2c3e50;
			margin-bottom: 30px;
			font-size: 2em;
		}
		form {
			background-color: white;
			padding: 25px;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.1);
			margin-bottom: 30px;
			max-width: 600px;
		}
		.form-row {
			display: flex;
			gap: 20px;
			margin-bottom: 20px;
			align-items: end;
		}
		.form-group {
			flex: 1;
			display: flex;
			flex-direction: column;
		}
		label {
			font-weight: bold;
			margin-bottom: 5px;
			color: #34495e;
			font-size: 0.95em;
		}
		input[type="date"], input[type="time"], select {
			padding: 10px;
			border: 2px solid #e1e8ed;
			border-radius: 4px;
			font-size: 1em;
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
			transition: border-color 0.3s ease;
		}
		input[type="date"]:focus, input[type="time"]:focus, select:focus {
			outline: none;
			border-color: #3498db;
			box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
		}
		select {
			background-color: white;
			cursor: pointer;
		}
		button[type="submit"] {
			background-color: #3498db;
			color: white;
			padding: 12px 30px;
			border: none;
			border-radius: 4px;
			font-size: 1.1em;
			font-weight: bold;
			cursor: pointer;
			transition: background-color 0.3s ease;
			width: 100%;
			margin-top: 10px;
		}
		button[type="submit"]:hover {
			background-color: #2980b9;
		}
		button[type="submit"]:active {
			transform: translateY(1px);
		}
		/* Responsive design for smaller screens */
		@media (max-width: 768px) {
			.form-row {
				flex-direction: column;
				gap: 15px;
			}
			form {
				margin: 0 10px 20px 10px;
				padding: 20px;
			}
			body {
				padding: 10px;
			}
		}
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
            text-align: right;
        }
                h2 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        /* Styles for the timeline */
        .timeline-container {
            width: 100%;
            padding: 20px 0;
            position: relative;
            padding-left: 150px; /* Space for date labels */
        }
        .timeline-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 50px; /* Increased vertical spacing between rows */
            overflow: visible;
            position: relative; /* Ensure proper positioning context */
            padding-top: 25px;
        }
        .timeline-date {
            position: absolute;
            left: 0;
            width: 130px;
            padding-top: 5px;
            text-align: left;
            transform: translateX(-150px); /* Move date label to the left */
        }
        .timeline-bar {
            width: 800px; /* Base width for the longest duration */
            height: 30px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #ddd;
            flex-shrink: 0;
        }
        .timeline-segment {
            height: 100%;
            transition: width 0.3s ease;
        }
        .timeline-segment.speed-30 {
            background-color: #ffe6cc;
        }
        .timeline-segment.speed-20 {
            background-color: #ccffcc;
        }
        .timeline-labels {
            position: absolute;
            display: flex;
            top: -35px;
            width: 100%;
            pointer-events: none;
        }
        .timeline-labels span {
            font-size: 0.9em;
            position: absolute;
            white-space: nowrap;
            top: 15px;
            transform: translateX(-50%);
        }
        .timeline-bar-container {
            position: absolute;
            display: flex;
            left: 150px; /* Position right after the date label (130px width + 20px gap) */
            min-width: 0; /* Prevent container from growing beyond parent width */
        }
        .slack-container {
            position: absolute;
            transform: translateX(-50%);
            text-align: center;
            min-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .tide-indicator {
            color: #468046;
            font-weight: bold;
            margin-bottom: 2p   x;
            font-size: 0.8em;
            white-space: nowrap;
        }
        .slack-time {
            color: #468046;
            font-weight: bold;
            background-color: #ffffff;
            padding: 0 4px;
            white-space: nowrap;
        }
        /* Styles for the main table */
        #results table {
            margin-bottom: 30px;
            width: auto; /* Allow table to size to content */
            table-layout: auto; /* Allow columns to size based on content */
        }
        #results td {
            text-align: right;
            white-space: nowrap; /* Prevent text wrapping */
            padding: 8px 12px; /* Add more horizontal padding for better spacing */
        }
        #results th {
            text-align: right;
            white-space: nowrap;
            padding: 8px 12px;
        }
        /* Specific column widths for optimal sizing */
        #results th:nth-child(1), #results td:nth-child(1) { /* Datum */
            width: 90px;
        }
        #results th:nth-child(2), #results td:nth-child(2) { /* Tijd */
            width: 60px;
        }
        #results th:nth-child(3), #results td:nth-child(3) { /* Stroming */
            width: 100px;
        }
        #results th:nth-child(4), #results td:nth-child(4) { /* Richting */
            width: 120px;
        }
        /* Collapsible header styles */
        .collapse-arrow {
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.3s ease;
        }
        #results h2:hover {
            color: #666;
        }
        .legend {
            margin-top: 20px;
            display: none; /* Hide legend by default */
        }
        .legend div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .legend .red {
            background-color: #ffcccc;
        }
        .legend .orange {
            background-color: #ffe6cc;
        }
        .legend .light-green {
            background-color: #ccffcc;
        }
        .legend .dark-green {
            background-color: #468046;
        }
        /* Loading spinner styles */
        .loading-spinner {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #666;
            font-style: italic;
        }
		#source {
			width: 100%;
			background-color: #f0f0f0; /* optional background color */
			padding: 10px;
			text-align: center;
			font-size: 12px; /* adjust the font size as needed */
			border-top: 1px solid #ccc; /* optional border at the top */
			margin-top: 20px;
		}
    </style>
</head>
<body>
    <h1>Duikkstek stromingsvoorspelling</h1>
    <form onsubmit="event.preventDefault(); fetchData();">
        <div class="form-row">
            <div class="form-group">
                <label for="diveSite">Duikplaats:</label>
                <select id="diveSite" required>
            <option value="burgd">Burghsluis</option>
            <option value="cpdl">Colijnsplaat</option>
            <option value="dypc">Dicky’s Place/Gemaal</option>
            <option value="dhdk">Dishoek</option>
            <option value="flauw">Flauwers</option>
            <option value="stvbevp">Goese Sas</option>
            <option value="ghdk">Gorishoek</option>
            <option value="hfwk">Havenhoofd West/Kurkenol</option>
            <option value="irhe">Irenehoeve</option>
            <option value="katsh">Katshoek</option>
            <option value="stvwemew">Kattendijke Parking</option>
            <option value="kstl">Kistersnol</option>
            <option value="lvnsd">Levensstrijd</option>
            <option value="oesp">Oesterputen</option>
            <option value="pltn">Plompe Toren</option>
            <option value="o11">Putti’s Place</option>
            <option value="quack">Quaack/Het oude Dorp</option>
            <option value="stvschk">Schelphoek</option>
            <option value="sphn">Sophiahaven</option>
            <option value="spak">Spyros Amenakis</option>
            <option value="stald">St Annaland</option>
            <option value="ston">Stavenisse Oostnol</option>
            <option value="stsgr">Stavenisse Steiger</option>
            <option value="strd">Strijenham</option>
            <option value="vlie">Vlietepolder</option>
            <option value="vlblt">Vuilnisbelt</option>
            <option value="grb">Wd De Groene Boei</option>
            <option value="dhoek">Wd De Hoek/Galjoen</option>
            <option value="wdoo">Wemeldinge Oost/Linda</option>
            <option value="wkkm">Westkapelle KNRM</option>
            <option value="znp1">Zeelandbrug 1e pijler</option>
            <option value="znp2">Zeelandbrug 2e pijler</option>
            <option value="zpmn">Zijpe (Midden)</option>
            <option value="znsn">Zonneschijn</option>
            <option value="zodk">Zoutelande</option>
            <option value="zubt">Zuidbout</option>
                </select>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="startDate">Startdatum:</label>
                <input type="date" id="startDate" required>
            </div>
            <div class="form-group">
                <label for="startTime">Starttijd:</label>
                <input type="time" id="startTime" required>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="endDate">Einddatum:</label>
                <input type="date" id="endDate" required>
            </div>
            <div class="form-group">
                <label for="endTime">Eindtijd:</label>
                <input type="time" id="endTime" required>
            </div>
        </div>
        <button type="submit">Toon stroming</button>
    </form>
    
    <div id="loading-spinner" class="loading-spinner">
        <div class="spinner"></div>
        <div class="loading-text">Stromingsgegevens laden...</div>
    </div>
    
    <div class="legend">
        <h2>Legenda</h2>
        <div><span class="red"></span> Duiken afgeraden (stroming > 30 cm/s)</div>
        <div><span class="orange"></span> Alleen ervaren getijdenduikers (stroming 20-30 cm/s)</div>
        <div><span class="light-green"></span> Alle getijdenduikers (stroming ≤ 20 cm/s)</div>
        <div><span class="dark-green"></span> Stromingskentering (vrijwel geen stroming)</div>
    </div>
    <div id="dive-windows"></div>
    <div id="results"></div>
	<div id="source">De informatie op deze pagina komt van <a href="https://waterberichtgeving.rws.nl/owb/regio/regio-zeeuwse-wateren/duikstekken-zeeland">Rijkswaterstaat Waterberichtgeving</a> en wordt weergegeven zoals deze is, zonder enige garanties.<div>
</body>
</html>
