<!-- 
Page to show the current forecast for a dive site in Zeeland, Netherlands.
This page fetches data from the Rijkswaterstaat Waterberichtgeving API and displays it in a table format.
The data includes current speed and direction, with color coding based on the current speed. 

The page also includes a legend to explain the color coding.
The user can select a dive site and specify a time range to get the forecast data.  
The selection of dive sites is based on the available data from the Rijkswaterstaat API.
The dates and times are set to default values of the current date and time, and two days later for the end date and time.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dive Site Data</title>
    <script>
        function setDefaultDateTime() {
            const now = new Date();
            const currentDate = now.toISOString().slice(0, 10);
            const currentTime = now.toTimeString().slice(0, 5);
            document.getElementById('startDate').value = currentDate;
            document.getElementById('startTime').value = currentTime;

            const later = new Date(now.getTime() + 48 * 60 * 60 * 1000);
            const endDate = later.toISOString().slice(0, 10);
            const endTime = later.toTimeString().slice(0, 5);
            document.getElementById('endDate').value = endDate;
            document.getElementById('endTime').value = endTime;
        }
        function getWindDirection(degrees) {
            // Define the wind direction abbreviations and their corresponding ranges
            const directions = [
                { abbr: "N", min: 337.5, max: 360 },
                { abbr: "N", min: 0, max: 22.5 },
                { abbr: "NE", min: 22.5, max: 67.5 },
                { abbr: "E", min: 67.5, max: 112.5 },
                { abbr: "SE", min: 112.5, max: 157.5 },
                { abbr: "S", min: 157.5, max: 202.5 },
                { abbr: "SW", min: 202.5, max: 247.5 },
                { abbr: "W", min: 247.5, max: 292.5 },
                { abbr: "NW", min: 292.5, max: 337.5 }
            ];

            // Normalize degrees to a range of 0 to 360
            degrees = degrees % 360;
            if (degrees < 0) degrees += 360;

            // Find the matching direction
            for (let i = 0; i < directions.length; i++) {
                const dir = directions[i];
                if (degrees >= dir.min && degrees < dir.max) {
                    return dir.abbr;
                }
            }

            // Default to "N" if no match is found (shouldn't happen with current logic)
            return "N";
        }

        async function fetchData() {
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const diveSite = document.getElementById('diveSite').value;

            const localStartDateTimeString = `${startDate}T${startTime}:00`;
            const localEndDateTimeString = `${endDate}T${endTime}:00`;

            const StartDateISO = LocalToUTC(localStartDateTimeString);
            const EndDateISO = LocalToUTC(localEndDateTimeString)

//            const url =   `https://waterberichtgeving.rws.nl/wb/data/api/dd/2.0/timeseries?observationTypeId=SG.1&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;
            const url = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?locationCode=${encodeURIComponent(diveSite)}&observationTypeId=SG_SOF_6.1.ms&sourceName=compute&&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&&`;
            const url_w = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?observationTypeId=SG.2&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;


            try {
                // get speed information
                const response = await fetch(url);
                const data = await response.json();
                // get direction information
                const response_w = await fetch(url_w);
                const data_w = await response_w.json();
                displayResults(data, data_w);
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        function displayResults(data ,data_w) {
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            if (data.results && data.results.length > 0) {
                const events = data.results[0].events;
                const events_w = data_w.results[0].events;

                // Create diving windows summary table
                const summaryTable = document.createElement('table');
                const summaryThead = document.createElement('thead');
                const summaryTbody = document.createElement('tbody');

                // Create summary table headers
                const summaryHeaderRow = document.createElement('tr');
                ['Date', 'Starts ≤30cm/s', 'Starts ≤20cm/s', 'Ends ≤20cm/s', 'Ends ≤30cm/s'].forEach(headerText => {
                    const header = document.createElement('th');
                    header.textContent = headerText;
                    summaryHeaderRow.appendChild(header);
                });
                summaryThead.appendChild(summaryHeaderRow);
                summaryTable.appendChild(summaryThead);

                // Find diving windows
                let windowStart = null;
                let start20 = null;
                let end20 = null;
                let end30 = null;
                let prevValue = null;

                events.forEach((event, index) => {
                    const value = parseFloat(event.value) * 100; // Convert to cm/s
                    
                    if (prevValue !== null) {
                        // Detect start of window (crossing below 0.3)
                        if (prevValue > 30 && value <= 30) {
                            windowStart = event;
                        }
                        // Detect crossing below 0.2
                        if (prevValue > 20 && value <= 20) {
                            start20 = event;
                        }
                        // Detect crossing above 0.2
                        if (prevValue <= 20 && value > 20) {
                            end20 = events[index - 1];
                        }
                        // Detect crossing above 0.3 (end of window)
                        if (prevValue <= 30 && value > 30) {
                            end30 = events[index - 1];
                            
                            // If we have a complete window, add it to the table
                            if (windowStart) {
                                const row = document.createElement('tr');
                                
                                // Helper function to format date/time
                                const formatDateTime = (evt) => {
                                    if (!evt) return '-';
                                    const localTime = UTCToLocal(evt.timeStamp);
                                    const localDateTimeString = localTime.toLocaleString();
                                    return localDateTimeString.split(', ')[1].substring(0,5);
                                };
                                
                                // Add date (from window start)
                                const dateCell = document.createElement('td');
                                const localTime = UTCToLocal(windowStart.timeStamp);
                                const localDateString = localTime.toLocaleString().split(', ')[0];
                                dateCell.textContent = localDateString;
                                row.appendChild(dateCell);
                                
                                // Add times
                                [windowStart, start20, end20, end30].forEach(evt => {
                                    const cell = document.createElement('td');
                                    cell.textContent = formatDateTime(evt);
                                    row.appendChild(cell);
                                });
                                
                                summaryTbody.appendChild(row);
                            }
                            
                            // Reset for next window
                            windowStart = null;
                            start20 = null;
                            end20 = null;
                            end30 = null;
                        }
                    }
                    prevValue = value;
                });

                // Check if we have an incomplete window at the end of the data
                if (windowStart) {
                    const row = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    const localTime = UTCToLocal(windowStart.timeStamp);
                    const localDateString = localTime.toLocaleString().split(', ')[0];
                    dateCell.textContent = localDateString;
                    row.appendChild(dateCell);
                    
                    [windowStart, start20, end20, end30].forEach(evt => {
                        const cell = document.createElement('td');
                        cell.textContent = evt ? UTCToLocal(evt.timeStamp).toLocaleString().split(', ')[1].substring(0,5) : '-';
                        row.appendChild(cell);
                    });
                    
                    summaryTbody.appendChild(row);
                }

                summaryTable.appendChild(summaryTbody);
                summaryTable.style.marginBottom = "20px";
                resultsContainer.appendChild(summaryTable);

                // Create main table
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Create table headers
                const headerRow = document.createElement('tr');
                const dateHeader = document.createElement('th');
                dateHeader.textContent = 'Date';
                const timeHeader = document.createElement('th');
                timeHeader.textContent = 'Time';
                const valueHeader = document.createElement('th');
                valueHeader.textContent = 'Current (cm/s)';
                const DirectionHeader = document.createElement('th');
                DirectionHeader.textContent = 'Direction';

                headerRow.appendChild(dateHeader);
                headerRow.appendChild(timeHeader);
                headerRow.appendChild(valueHeader);
                headerRow.appendChild(DirectionHeader);
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Find the lowest values in each sequence of values below 20
                let lowestValue = null;
                let lowestValueIndex = -1;

                events.forEach((event, index) => {
                    const value = parseFloat(event.value);
                    if (value < 20) {
                        if (lowestValue === null || value < lowestValue) {
                            lowestValue = value;
                            lowestValueIndex = index;
                        }
                    } else {
                        if (lowestValue !== null) {
                            events[lowestValueIndex].isLowest = true;
                        }
                        lowestValue = null;
                        lowestValueIndex = -1;
                    }
                });

                // Check the last sequence
                if (lowestValue !== null) {
                    events[lowestValueIndex].isLowest = true;
                }

                // Populate table rows
                var i = -1;
                events.forEach(event => {
                    i++;
                    if (!event.value) {
                        return;
                    }
                    const row = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    const timeCell = document.createElement('td');
                    const valueCell = document.createElement('td');
                    const directionCell = document.createElement('td');

                    // Split the timestamp into date and time parts
					const localTime = UTCToLocal(event.timeStamp);
                    const localDateTimeString = localTime.toLocaleString();
                    const localDateString = localDateTimeString.split(', ')[0];
                    const localTimeString = localDateTimeString.split(', ')[1].substring(0,5);
                    
                    Date().toLocaleString
                    dateCell.textContent = localDateString;
                    timeCell.textContent = localTimeString;
                    valueCell.textContent = Math.round(event.value * 100);
                    directionCell.textContent = events_w[i].value + " (" +  getWindDirection(events_w[i].value) + ")";

                    // Apply background color based on value
                    const value = parseFloat(event.value);
                    if (event.isLowest) {
                        row.style.backgroundColor = '#99ff99'; // darker green
                    } else if (value > 0.30) {
                        row.style.backgroundColor = '#ffcccc'; // light pastel red
                    } else if (value > 0.20) {
                        row.style.backgroundColor = '#ffe6cc'; // light pastel orange
                    } else {
                        row.style.backgroundColor = '#ccffcc'; // light pastel green
                    }
                    row.appendChild(dateCell);
                    row.appendChild(timeCell);
                    row.appendChild(valueCell);
                    row.appendChild(directionCell);
                    tbody.appendChild(row);
                });

                table.appendChild(tbody);
                resultsContainer.appendChild(table);
            } else {
                resultsContainer.textContent = 'No results found.';
            }
        }
        
        function UTCToLocal(utcstring) {
            utcISOString = utcstring.replace(':00Z',':00.000Z');
            var strUTC = ( new Date(utcISOString) ).toISOString();
            var datetimeLocal = new Date( strUTC );

            return datetimeLocal; 
        }


        function LocalToUTC(localstring) {

            var strUTC = ( new Date(localstring) ).toISOString();
            strUTCFormatted = strUTC.replace(':00.000Z',':00Z');
            return strUTCFormatted; 
            
        }
        
        window.onload = setDefaultDateTime;
    </script>
    <style>
		body {
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
		}
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
            text-align: left;
        }
        /* Styles for the summary table */
        #results table:first-child {
            margin-bottom: 30px;
        }
        #results table:first-child th {
            background-color: #e6ffe6;
            text-align: center;
        }
        #results table:first-child td {
            text-align: center;
        }
        .legend {
            margin-top: 20px;
        }
        .legend div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .legend .red {
            background-color: #ffcccc;
        }
        .legend .orange {
            background-color: #ffe6cc;
        }
        .legend .light-green {
            background-color: #ccffcc;
        }
        .legend .dark-green {
            background-color: #99ff99;
        }
		#source {
			position: fixed;
			bottom: 0;
			left: 0;
			width: 100%;
			background-color: #f0f0f0; /* optional background color */
			padding: 10px;
			text-align: center;
			font-size: 12px; /* adjust the font size as needed */
			border-top: 1px solid #ccc; /* optional border at the top */
		}
    </style>
</head>
<body>
    <h1>Dive site current forecast</h1>
    <form onsubmit="event.preventDefault(); fetchData();">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" required>
        <label for="startTime">Start Time:</label>
        <input type="time" id="startTime" required>
        <br>
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" required>
        <label for="endTime">End Time:</label>
        <input type="time" id="endTime" required>
        <br>
        <label for="diveSite">Dive Site:</label>
        <select id="diveSite" required>
            <option value="burgd">Burghsluis</option>
            <option value="cpdl">Colijnsplaat</option>
            <option value="dypc">Dicky’s Place/Gemaal</option>
            <option value="dhdk">Dishoek</option>
            <option value="flauw">Flauwers</option>
            <option value="stvbevp">Goese Sas</option>
            <option value="ghdk">Gorishoek</option>
            <option value="hfwk">Havenhoofd West/Kurkenol</option>
            <option value="irhe">Irenehoeve</option>
            <option value="katsh">Katshoek</option>
            <option value="stvwemew">Kattendijke Parking</option>
            <option value="kstl">Kistersnol</option>
            <option value="lvnsd">Levensstrijd</option>
            <option value="oesp">Oesterputen</option>
            <option value="pltn">Plompe Toren</option>
            <option value="o11">Putti’s Place</option>
            <option value="quack">Quaack/Het oude Dorp</option>
            <option value="stvschk">Schelphoek</option>
            <option value="sphn">Sophiahaven</option>
            <option value="spak">Spyros Amenakis</option>
            <option value="stald">St Annaland</option>
            <option value="ston">Stavenisse Oostnol</option>
            <option value="stsgr">Stavenisse Steiger</option>
            <option value="strd">Strijenham</option>
            <option value="vlie">Vlietepolder</option>
            <option value="vlblt">Vuilnisbelt</option>
            <option value="grb">Wd De Groene Boei</option>
            <option value="dhoek">Wd De Hoek/Galjoen</option>
            <option value="wdoo">Wemeldinge Oost/Linda</option>
            <option value="wkkm">Westkapelle KNRM</option>
            <option value="znp1">Zeelandbrug 1e pijler</option>
            <option value="znp2">Zeelandbrug 2e pijler</option>
            <option value="zpmn">Zijpe (Midden)</option>
            <option value="znsn">Zonneschijn</option>
            <option value="zodk">Zoutelande</option>
            <option value="zubt">Zuidbout</option>
        </select>
        <br>
        <button type="submit">Get Data</button>
    </form>
    <div class="legend">
        <h2>Legend</h2>
        <div><span class="red"></span> Diving not advised (current > 30 cm/s)</div>
        <div><span class="orange"></span> Only experienced tidal divers (current 20-30 cm/s)</div>
        <div><span class="light-green"></span> All tidal divers (current ≤ 20 cm/s)</div>
        <div><span class="dark-green"></span> Moment of slack tide (hardly any current)</div>
    </div>
    <div id="results"></div>
	<div id="source">Information on this page is retrieved from <a href="https://waterberichtgeving.rws.nl/owb/regio/regio-zeeuwse-wateren/duikstekken-zeeland">Rijkswaterstaat Waterberichtgeving</a> and displayed as is, without any warrantees.<div>
</body>
</html>
