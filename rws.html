<!-- 
Page to show the current forecast for a dive site in Zeeland, Netherlands.
This page fetches data from the Rijkswaterstaat Waterberichtgeving API and displays it in a table format.
The data includes current speed and direction, with color coding based on the current speed. 

The page also includes a legend to explain the color coding.
The user can select a dive site and specify a time range to get the forecast data.  
The selection of dive sites is based on the available data from the Rijkswaterstaat API.
The dates and times are set to default values of the current date and time, and two days later for the end date and time.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dive Site Data</title>
    <script>
        function setDefaultDateTime() {
            const now = new Date();
            const currentDate = now.toISOString().slice(0, 10);
            const currentTime = now.toTimeString().slice(0, 5);
            document.getElementById('startDate').value = currentDate;
            document.getElementById('startTime').value = currentTime;

            const later = new Date(now.getTime() + 48 * 60 * 60 * 1000);
            const endDate = later.toISOString().slice(0, 10);
            const endTime = later.toTimeString().slice(0, 5);
            document.getElementById('endDate').value = endDate;
            document.getElementById('endTime').value = endTime;
        }
        function getWindDirection(degrees) {
            // Define the wind direction abbreviations and their corresponding ranges
            const directions = [
                { abbr: "N", min: 337.5, max: 360 },
                { abbr: "N", min: 0, max: 22.5 },
                { abbr: "NE", min: 22.5, max: 67.5 },
                { abbr: "E", min: 67.5, max: 112.5 },
                { abbr: "SE", min: 112.5, max: 157.5 },
                { abbr: "S", min: 157.5, max: 202.5 },
                { abbr: "SW", min: 202.5, max: 247.5 },
                { abbr: "W", min: 247.5, max: 292.5 },
                { abbr: "NW", min: 292.5, max: 337.5 }
            ];

            // Normalize degrees to a range of 0 to 360
            degrees = degrees % 360;
            if (degrees < 0) degrees += 360;

            // Find the matching direction
            for (let i = 0; i < directions.length; i++) {
                const dir = directions[i];
                if (degrees >= dir.min && degrees < dir.max) {
                    return dir.abbr;
                }
            }

            // Default to "N" if no match is found (shouldn't happen with current logic)
            return "N";
        }

        async function fetchData() {
            // Clear containers immediately when button is pressed
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            const loadingSpinner = document.getElementById('loading-spinner');
            const legend = document.querySelector('.legend');
            
            diveWindowsContainer.innerHTML = '';
            resultsContainer.innerHTML = '';
            
            // Hide legend and show loading spinner
            legend.style.display = 'none';
            loadingSpinner.style.display = 'block';

            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const diveSite = document.getElementById('diveSite').value;

            const localStartDateTimeString = `${startDate}T${startTime}:00`;
            const localEndDateTimeString = `${endDate}T${endTime}:00`;

            const StartDateISO = LocalToUTC(localStartDateTimeString);
            const EndDateISO = LocalToUTC(localEndDateTimeString)

//            const url =   `https://waterberichtgeving.rws.nl/wb/data/api/dd/2.0/timeseries?observationTypeId=SG.1&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;
            // Use the RWS API to fetch data for the selected dive site and time range
            // Note: The observationTypeId and sourceName are hardcoded based on the API documentation 
            // url is the URL to fetch the water speed data, and url_w is the URL to fetch the water direction data
            const url = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?locationCode=${encodeURIComponent(diveSite)}&observationTypeId=SG_SOF_6.1.ms&sourceName=compute&&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&&`;
            const url_w = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?observationTypeId=SG.2&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;

            try {
                // get speed information
                const response = await fetch(url);
                const data = await response.json();
                // get direction information
                const response_w = await fetch(url_w);
                const data_w = await response_w.json();
                displayResults(data, data_w);
            } catch (error) {
                console.error('Error fetching data:', error);
                resultsContainer.textContent = 'Fout bij het ophalen van gegevens. Probeer het opnieuw.';
            } finally {
                // Hide loading spinner when done (success or error)
                loadingSpinner.style.display = 'none';
            }
        }

        function displayResults(data ,data_w) {
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            const legend = document.querySelector('.legend');

            if (data.results && data.results.length > 0) {
                // events contains all water speed data in 10 minute increments 
                const events = data.results[0].events;
                // events_w contains all water direction data in 10 minute increments
                // Note: this is the same time series as events, but with different values
                const events_w = data_w.results[0].events;

                // Helper function to calculate minutes between two timestamps
                const getMinutesBetween = (start, end) => {
                    if (!start || !end) return 0;
                    return (new Date(end.timeStamp) - new Date(start.timeStamp)) / (1000 * 60);
                };

                // Add header for dive windows section
                const diveWindowsHeader = document.createElement('h2');
                diveWindowsHeader.textContent = 'Duikvensters';
                diveWindowsContainer.appendChild(diveWindowsHeader);

                // Create timeline container
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'timeline-container';

                // First pass: find all windows and determine the longest duration
                let maxDuration = 0;
                let windows = [];
                let windowStart = null;
                let start20 = null;
                let end20 = null;
                let end30 = null;
                let prevValue = null;

                events.forEach((event, index) => {
                    const value = parseFloat(event.value) * 100; // Convert to cm/s
                    
                    if (prevValue !== null) {
                        // Detect start of window (crossing below 0.3)
                        if (prevValue > 30 && value <= 30) {
                            windowStart = event;
                        }
                        // Detect crossing below 0.2
                        if (prevValue > 20 && value <= 20) {
                            start20 = event;
                        }
                        // Detect crossing above 0.2
                        if (prevValue <= 20 && value > 20) {
                            end20 = events[index - 1];
                        }
                        // Detect crossing above 0.3 (end of window)
                        if (prevValue <= 30 && value > 30) {
                            end30 = events[index - 1];
                            
                            // If we have a complete window, check if it's a valid tide window
                            if (windowStart) {
                                const windowStartIndex = events.findIndex(e => e === windowStart);
                                const windowEndIndex = events.findIndex(e => e === end30);
                                
                                if (windowStartIndex !== -1 && windowEndIndex !== -1) {
                                    const startDirection = parseFloat(events_w[windowStartIndex].value);
                                    const endDirection = parseFloat(events_w[windowEndIndex].value);
                                    
                                    // Only store the window if there's a direction change (one value above 180, one below)
                                    if ((startDirection > 180 && endDirection < 180) || 
                                        (startDirection < 180 && endDirection > 180)) {
                                        const duration = getMinutesBetween(windowStart, end30);
                                        maxDuration = Math.max(maxDuration, duration);
                                        windows.push({
                                            windowStart,
                                            start20,
                                            end20,
                                            end30,
                                            duration
                                        });
                                    }
                                }
                            }
                            
                            // Reset for next window
                            windowStart = null;
                            start20 = null;
                            end20 = null;
                            end30 = null;
                        }
                    }
                    prevValue = value;
                });

                // Calculate each window's slack time position
                windows.forEach(window => {
                    if (window.start20 && window.end20) {
                        const start20Index = events.findIndex(e => e === window.start20);
                        const end20Index = events.findIndex(e => e === window.end20);
                        
                        // Find slack time - direction change with lowest water speed
                        let bestSlackIndex = -1;
                        let lowestSpeed = Infinity;
                        
                        for (let i = start20Index; i < end20Index; i++) {
                            const currentDir = parseFloat(events_w[i].value);
                            const nextDir = parseFloat(events_w[i + 1].value);
                            if ((currentDir > 180 && nextDir < 180) || (currentDir < 180 && nextDir > 180)) {
                                // Compare speeds at both points and use the lower one
                                const currentSpeed = parseFloat(events[i].value);
                                const nextSpeed = parseFloat(events[i + 1].value);
                                const minSpeed = Math.min(currentSpeed, nextSpeed);
                                
                                if (minSpeed < lowestSpeed) {
                                    lowestSpeed = minSpeed;
                                    bestSlackIndex = currentSpeed < nextSpeed ? i : i + 1;
                                }
                            }
                        }
                        
                        if (bestSlackIndex !== -1) {
                            window.slackTime = events[bestSlackIndex];
                            window.slackTimeFromStart = getMinutesBetween(window.windowStart, events[bestSlackIndex]);
                            
                            // Determine tide indicator by finding the direction change around bestSlackIndex
                            let beforeDirection, afterDirection;
                            if (bestSlackIndex > 0) {
                                beforeDirection = parseFloat(events_w[bestSlackIndex - 1].value);
                                afterDirection = parseFloat(events_w[bestSlackIndex].value);
                            } else {
                                beforeDirection = parseFloat(events_w[bestSlackIndex].value);
                                afterDirection = parseFloat(events_w[bestSlackIndex + 1].value);
                            }
                            
                            if (beforeDirection > 180 && afterDirection < 180) {
                                window.tideIndicator = 'LW';
                            } else if (beforeDirection < 180 && afterDirection > 180) {
                                window.tideIndicator = 'HW';
                            }
                        }
                    }
                });

                // Calculate slack times and find the maximum offset needed
                let maxLeftOffset = 0;
                let maxRightOffset = 0;
                let referencePoint = 400; // Center point for alignment (half of 800px max width)
                
                // First pass: calculate all offsets
                windows.forEach(window => {
                    if (window.slackTime) {
                        const slackTimeFromStart = window.slackTimeFromStart;
                        const timeFromSlackToEnd = getMinutesBetween(window.slackTime, window.end30);
                        maxLeftOffset = Math.max(maxLeftOffset, slackTimeFromStart);
                        maxRightOffset = Math.max(maxRightOffset, timeFromSlackToEnd);
                    }
                });
                
                // Second pass: create timeline rows with bars scaled to maxDuration
                windows.forEach(window => {
                    const timelineRow = document.createElement('div');
                    timelineRow.className = 'timeline-row';
                    
                    // Add date label
                    const dateLabel = document.createElement('div');
                    dateLabel.className = 'timeline-date';
                    const localTime = UTCToLocal(window.windowStart.timeStamp);
                    const localDateString = localTime.toLocaleString().split(', ')[0];
                    dateLabel.textContent = localDateString;
                    
                    timelineRow.appendChild(dateLabel);

                    // Create container for the bar and labels
                    const timelineBarContainer = document.createElement('div');
                    timelineBarContainer.className = 'timeline-bar-container';

                    // Create timeline bar
                    const timelineBar = document.createElement('div');
                    timelineBar.className = 'timeline-bar';
                    const barWidth = Math.min((window.duration / maxDuration) * 800, 800);
                    timelineBar.style.width = `${barWidth}px`;
                    
                    // Position the bar so its slack time aligns with others
                    if (window.slackTime) {
                        const slackPosition = (window.slackTimeFromStart / window.duration) * barWidth;
                        const leftOffset = referencePoint - slackPosition;
                        timelineBarContainer.style.marginLeft = `${leftOffset}px`;
                    }

                    if (window.start20) {
                        // First segment (>20 to ≤30)
                        const segment1 = document.createElement('div');
                        segment1.className = 'timeline-segment speed-30';
                        const width1 = (getMinutesBetween(window.windowStart, window.start20) / window.duration) * 100;
                        segment1.style.width = `${width1}%`;
                        timelineBar.appendChild(segment1);

                        if (window.end20) {
                            // Middle segment (≤20)
                            const segment2 = document.createElement('div');
                            segment2.className = 'timeline-segment speed-20';
                            const width2 = (getMinutesBetween(window.start20, window.end20) / window.duration) * 100;
                            segment2.style.width = `${width2}%`;
                            segment2.style.position = 'relative'; // For absolute positioning of slack indicator
                            
                            // Find slack tide moment within ≤20 period
                            const start20Index = events.findIndex(e => e === window.start20);
                            const end20Index = events.findIndex(e => e === window.end20);
                            if (start20Index !== -1 && end20Index !== -1) {
                                // Search for the direction change with lowest water speed
                                let bestSlackIndex = -1;
                                let lowestSpeed = Infinity;

                                for (let i = start20Index; i < end20Index; i++) {
                                    const currentDir = parseFloat(events_w[i].value);
                                    const nextDir = parseFloat(events_w[i + 1].value);
                                    if ((currentDir > 180 && nextDir < 180) || (currentDir < 180 && nextDir > 180)) {
                                        // Compare speeds at both points and use the lower one
                                        const currentSpeed = parseFloat(events[i].value);
                                        const nextSpeed = parseFloat(events[i + 1].value);
                                        const minSpeed = Math.min(currentSpeed, nextSpeed);
                                        
                                        if (minSpeed < lowestSpeed) {
                                            lowestSpeed = minSpeed;
                                            bestSlackIndex = currentSpeed < nextSpeed ? i : i + 1;
                                        }
                                    }
                                }

                                if (bestSlackIndex !== -1) {
                                    const slackTime = events[bestSlackIndex];
                                    
                                    // Calculate the relative position of slack time within the green segment
                                    const slackTimeOffset = (getMinutesBetween(window.start20, slackTime) / getMinutesBetween(window.start20, window.end20)) * 100;
                                    
                                    // Create slack indicator
                                    const slackContainer = document.createElement('div');
                                    slackContainer.style.position = 'absolute';
                                    slackContainer.style.left = `${slackTimeOffset}%`;
                                    slackContainer.style.top = '0';
                                    slackContainer.style.height = '100%';
                                    slackContainer.style.transform = 'translateX(-50%)';
                                    slackContainer.style.width = '2px';
                                    slackContainer.style.backgroundColor = '#006600';
                                    slackContainer.style.zIndex = '2';

                                    // Store the slack time, offset, and tide indicator for later use
                                    window.slackTime = slackTime;
                                    window.slackTimeFromStart = getMinutesBetween(window.windowStart, slackTime);
                                    
                                    // Determine tide indicator by finding the direction change around bestSlackIndex
                                    let beforeDirection, afterDirection;
                                    if (bestSlackIndex > 0) {
                                        beforeDirection = parseFloat(events_w[bestSlackIndex - 1].value);
                                        afterDirection = parseFloat(events_w[bestSlackIndex].value);
                                    } else {
                                        beforeDirection = parseFloat(events_w[bestSlackIndex].value);
                                        afterDirection = parseFloat(events_w[bestSlackIndex + 1].value);
                                    }
                                    
                                    if (beforeDirection > 180 && afterDirection < 180) {
                                        window.tideIndicator = 'LW';
                                    } else if (beforeDirection < 180 && afterDirection > 180) {
                                        window.tideIndicator = 'HW';
                                    }
                                    
                                    // Add container to segment
                                    segment2.appendChild(slackContainer);
                                }
                            }
                            
                            timelineBar.appendChild(segment2);

                            // Last segment (>20 to ≤30)
                            const segment3 = document.createElement('div');
                            segment3.className = 'timeline-segment speed-30';
                            const width3 = (getMinutesBetween(window.end20, window.end30) / window.duration) * 100;
                            segment3.style.width = `${width3}%`;
                            timelineBar.appendChild(segment3);
                        } else {
                            // Remaining segment (≤20)
                            const segment2 = document.createElement('div');
                            segment2.className = 'timeline-segment speed-20';
                            const width2 = (getMinutesBetween(window.start20, window.end30) / window.duration) * 100;
                            segment2.style.width = `${width2}%`;
                            timelineBar.appendChild(segment2);
                        }
                    } else {
                        // Single segment for entire window (≤30)
                        const segment = document.createElement('div');
                        segment.className = 'timeline-segment speed-30';
                        segment.style.width = '100%';
                        timelineBar.appendChild(segment);
                    }

                    timelineRow.appendChild(timelineBar);

                    // Add time labels
                    const timeLabels = document.createElement('div');
                    timeLabels.className = 'timeline-labels';

                    // Helper function to create positioned label
                    const createLabel = (evt, position) => {
                        if (evt) {
                            const label = document.createElement('span');
                            label.textContent = UTCToLocal(evt.timeStamp).toLocaleString().split(', ')[1].substring(0,5);
                            label.style.left = `${position}px`;
                            label.className = 'start';
                            timeLabels.appendChild(label);
                        }
                    };

                    // Calculate pixel positions for labels based on the actual bar width
                    let currentPosition = 0;
                    
                    // Start of window (<=0.3)
                    createLabel(window.windowStart, 0);

                    if (window.start20) {
                        // Time when <=0.2 starts
                        const start20Pixels = (getMinutesBetween(window.windowStart, window.start20) / window.duration) * barWidth;
                        createLabel(window.start20, start20Pixels);

                        if (window.end20) {
                            // Time when >0.2 starts
                            const end20Pixels = (getMinutesBetween(window.windowStart, window.end20) / window.duration) * barWidth;
                            createLabel(window.end20, end20Pixels);
                        }
                    }

                    // End of window (>0.3)
                    createLabel(window.end30, barWidth);

                    // Add slack time label if it exists
                    if (window.slackTime) {
                        const slackLabelPosition = (window.slackTimeFromStart / window.duration) * barWidth;
                        
                        // Create container for slack time and tide indicator
                        const slackContainer = document.createElement('div');
                        slackContainer.className = 'slack-container';
                        slackContainer.style.left = `${slackLabelPosition}px`;
                        
                        // Add tide indicator if it exists
                        if (window.tideIndicator) {
                            const tideLabel = document.createElement('div');
                            tideLabel.textContent = window.tideIndicator;
                            tideLabel.className = 'tide-indicator';
                            slackContainer.appendChild(tideLabel);
                        }
                        
                        // Add slack time
                        const slackLabel = document.createElement('div');
                        slackLabel.textContent = UTCToLocal(window.slackTime.timeStamp).toLocaleString().split(', ')[1].substring(0,5);
                        slackLabel.className = 'slack-time';
                        slackContainer.appendChild(slackLabel);
                        
                        timeLabels.appendChild(slackContainer);
                        
                        // Clean up
                        delete window.slackTime;
                        delete window.slackTimeFromStart;
                        delete window.tideIndicator;
                    }

                    timelineBarContainer.appendChild(timelineBar);
                    timelineBarContainer.appendChild(timeLabels);
                    timelineRow.appendChild(timelineBarContainer);
                    
                    timelineContainer.appendChild(timelineRow);
                });

                timelineContainer.style.marginBottom = "20px";
                diveWindowsContainer.appendChild(timelineContainer);

                // Add header for current details section
                const currentDetailsHeader = document.createElement('h2');
                currentDetailsHeader.style.cursor = 'pointer';
                currentDetailsHeader.style.userSelect = 'none';
                currentDetailsHeader.innerHTML = '<span class="collapse-arrow">▼</span> Stromingsdetails';
                
                // Create container for collapsible content
                const detailsContainer = document.createElement('div');
                detailsContainer.id = 'details-container';
                detailsContainer.style.display = 'none'; // Collapsed by default
                
                // Add click handler to toggle collapse
                currentDetailsHeader.addEventListener('click', function() {
                    const arrow = this.querySelector('.collapse-arrow');
                    if (detailsContainer.style.display === 'none') {
                        detailsContainer.style.display = 'block';
                        arrow.textContent = '▲';
                    } else {
                        detailsContainer.style.display = 'none';
                        arrow.textContent = '▼';
                    }
                });
                
                resultsContainer.appendChild(currentDetailsHeader);

                // Create main table
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Create table headers
                const headerRow = document.createElement('tr');
                const dateHeader = document.createElement('th');
                dateHeader.textContent = 'Datum';
                const timeHeader = document.createElement('th');
                timeHeader.textContent = 'Tijd';
                const valueHeader = document.createElement('th');
                valueHeader.textContent = 'Stroming (cm/s)';
                const DirectionHeader = document.createElement('th');
                DirectionHeader.textContent = 'Richting (°)';

                headerRow.appendChild(dateHeader);
                headerRow.appendChild(timeHeader);
                headerRow.appendChild(valueHeader);
                headerRow.appendChild(DirectionHeader);
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Find slack times based on direction changes with lowest water speed
                events.forEach((event, index) => {
                    if (index < events.length - 1) {
                        const currentDir = parseFloat(events_w[index].value);
                        const nextDir = parseFloat(events_w[index + 1].value);
                        
                        // Check for direction change
                        if ((currentDir > 180 && nextDir < 180) || (currentDir < 180 && nextDir > 180)) {
                            // Compare speeds at both points and mark the one with lower speed as slack
                            const currentSpeed = parseFloat(events[index].value);
                            const nextSpeed = parseFloat(events[index + 1].value);
                            
                            if (currentSpeed < nextSpeed) {
                                events[index].isLowest = true;
                            } else {
                                events[index + 1].isLowest = true;
                            }
                        }
                    }
                });

                // Populate table rows
                var i = -1;
                events.forEach(event => {
                    i++;
                    if (!event.value) {
                        return;
                    }
                    const row = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    const timeCell = document.createElement('td');
                    const valueCell = document.createElement('td');
                    const directionCell = document.createElement('td');

                    // Split the timestamp into date and time parts
					const localTime = UTCToLocal(event.timeStamp);
                    const localDateTimeString = localTime.toLocaleString();
                    const localDateString = localDateTimeString.split(', ')[0];
                    const localTimeString = localDateTimeString.split(', ')[1].substring(0,5);
                    
                    Date().toLocaleString
                    dateCell.textContent = localDateString;
                    timeCell.textContent = localTimeString;
                    valueCell.textContent = Math.round(event.value * 100);
                    directionCell.textContent = events_w[i].value + " (" +  getWindDirection(events_w[i].value) + ")";

                    // Apply background color based on value
                    const value = parseFloat(event.value);
                    if (event.isLowest) {
                        row.style.backgroundColor = '#99ff99'; // darker green
                    } else if (value > 0.30) {
                        row.style.backgroundColor = '#ffcccc'; // light pastel red
                    } else if (value > 0.20) {
                        row.style.backgroundColor = '#ffe6cc'; // light pastel orange
                    } else {
                        row.style.backgroundColor = '#ccffcc'; // light pastel green
                    }
                    row.appendChild(dateCell);
                    row.appendChild(timeCell);
                    row.appendChild(valueCell);
                    row.appendChild(directionCell);
                    tbody.appendChild(row);
                });

                table.appendChild(tbody);
                detailsContainer.appendChild(table);
                resultsContainer.appendChild(detailsContainer);
                
                // Show legend now that results are displayed
                legend.style.display = 'block';
            } else {
                resultsContainer.textContent = 'No results found.';
            }
        }
        
        function UTCToLocal(utcstring) {
            utcISOString = utcstring.replace(':00Z',':00.000Z');
            var strUTC = ( new Date(utcISOString) ).toISOString();
            var datetimeLocal = new Date( strUTC );

            return datetimeLocal; 
        }


        function LocalToUTC(localstring) {

            var strUTC = ( new Date(localstring) ).toISOString();
            strUTCFormatted = strUTC.replace(':00.000Z',':00Z');
            return strUTCFormatted; 
            
        }
        
        window.onload = setDefaultDateTime;
    </script>
    <style>
		body {
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
			margin: 0;
			padding: 20px;
			background-color: #f8f9fa;
		}
		/* Form styling */
		h1 {
			color: #2c3e50;
			margin-bottom: 30px;
			font-size: 2em;
		}
		form {
			background-color: white;
			padding: 25px;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0,0,0,0.1);
			margin-bottom: 30px;
			max-width: 600px;
		}
		.form-row {
			display: flex;
			gap: 20px;
			margin-bottom: 20px;
			align-items: end;
		}
		.form-group {
			flex: 1;
			display: flex;
			flex-direction: column;
		}
		label {
			font-weight: bold;
			margin-bottom: 5px;
			color: #34495e;
			font-size: 0.95em;
		}
		input[type="date"], input[type="time"], select {
			padding: 10px;
			border: 2px solid #e1e8ed;
			border-radius: 4px;
			font-size: 1em;
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
			transition: border-color 0.3s ease;
		}
		input[type="date"]:focus, input[type="time"]:focus, select:focus {
			outline: none;
			border-color: #3498db;
			box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
		}
		select {
			background-color: white;
			cursor: pointer;
		}
		button[type="submit"] {
			background-color: #3498db;
			color: white;
			padding: 12px 30px;
			border: none;
			border-radius: 4px;
			font-size: 1.1em;
			font-weight: bold;
			cursor: pointer;
			transition: background-color 0.3s ease;
			width: 100%;
			margin-top: 10px;
		}
		button[type="submit"]:hover {
			background-color: #2980b9;
		}
		button[type="submit"]:active {
			transform: translateY(1px);
		}
		/* Responsive design for smaller screens */
		@media (max-width: 768px) {
			.form-row {
				flex-direction: column;
				gap: 15px;
			}
			form {
				margin: 0 10px 20px 10px;
				padding: 20px;
			}
			body {
				padding: 10px;
			}
		}
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
            text-align: right;
        }
                h2 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        /* Styles for the timeline */
        .timeline-container {
            width: 100%;
            padding: 20px 0;
            position: relative;
            padding-left: 150px; /* Space for date labels */
        }
        .timeline-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 50px; /* Increased vertical spacing between rows */
            overflow: visible;
            position: relative; /* Ensure proper positioning context */
        }
        .timeline-date {
            position: absolute;
            left: 0;
            width: 130px;
            padding-top: 5px;
            text-align: left;
            transform: translateX(-150px); /* Move date label to the left */
        }
        .timeline-bar {
            width: 800px; /* Base width for the longest duration */
            height: 30px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #ddd;
            flex-shrink: 0;
        }
        .timeline-segment {
            height: 100%;
            transition: width 0.3s ease;
        }
        .timeline-segment.speed-30 {
            background-color: #ffcccc;
        }
        .timeline-segment.speed-20 {
            background-color: #ccffcc;
        }
        .timeline-labels {
            position: absolute;
            display: flex;
            top: -35px;
            width: 100%;
            pointer-events: none;
        }
        .timeline-labels span {
            font-size: 0.9em;
            position: absolute;
            white-space: nowrap;
            top: 15px;
            transform: translateX(-50%);
        }
        .timeline-bar-container {
            position: absolute;
            display: flex;
            left: 150px; /* Position right after the date label (130px width + 20px gap) */
            min-width: 0; /* Prevent container from growing beyond parent width */
        }
        .slack-container {
            position: absolute;
            transform: translateX(-50%);
            text-align: center;
            min-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .tide-indicator {
            color: #006600;
            font-weight: bold;
            margin-bottom: 2px;
            font-size: 0.8em;
            white-space: nowrap;
        }
        .slack-time {
            color: #006600;
            font-weight: bold;
            background-color: #ffffff;
            padding: 0 4px;
            white-space: nowrap;
        }
        .timeline-row {
            position: relative;
            padding-top: 25px;
        }
        /* Styles for the main table */
        #results table {
            margin-bottom: 30px;
            width: auto; /* Allow table to size to content */
            table-layout: auto; /* Allow columns to size based on content */
        }
        #results td {
            text-align: right;
            white-space: nowrap; /* Prevent text wrapping */
            padding: 8px 12px; /* Add more horizontal padding for better spacing */
        }
        #results th {
            text-align: right;
            white-space: nowrap;
            padding: 8px 12px;
        }
        /* Specific column widths for optimal sizing */
        #results th:nth-child(1), #results td:nth-child(1) { /* Datum */
            width: 90px;
        }
        #results th:nth-child(2), #results td:nth-child(2) { /* Tijd */
            width: 60px;
        }
        #results th:nth-child(3), #results td:nth-child(3) { /* Stroming */
            width: 100px;
        }
        #results th:nth-child(4), #results td:nth-child(4) { /* Richting */
            width: 120px;
        }
        /* Collapsible header styles */
        .collapse-arrow {
            font-size: 0.8em;
            margin-right: 8px;
            transition: transform 0.3s ease;
        }
        #results h2:hover {
            color: #666;
        }
        .legend {
            margin-top: 20px;
            display: none; /* Hide legend by default */
        }
        .legend div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .legend .red {
            background-color: #ffcccc;
        }
        .legend .orange {
            background-color: #ffe6cc;
        }
        .legend .light-green {
            background-color: #ccffcc;
        }
        .legend .dark-green {
            background-color: #99ff99;
        }
        /* Loading spinner styles */
        .loading-spinner {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #666;
            font-style: italic;
        }
		#source {
			width: 100%;
			background-color: #f0f0f0; /* optional background color */
			padding: 10px;
			text-align: center;
			font-size: 12px; /* adjust the font size as needed */
			border-top: 1px solid #ccc; /* optional border at the top */
			margin-top: 20px;
		}
    </style>
</head>
<body>
    <h1>Duikkstek stromingsvoorspelling</h1>
    <form onsubmit="event.preventDefault(); fetchData();">
        <div class="form-row">
            <div class="form-group">
                <label for="startDate">Startdatum:</label>
                <input type="date" id="startDate" required>
            </div>
            <div class="form-group">
                <label for="startTime">Starttijd:</label>
                <input type="time" id="startTime" required>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="endDate">Einddatum:</label>
                <input type="date" id="endDate" required>
            </div>
            <div class="form-group">
                <label for="endTime">Eindtijd:</label>
                <input type="time" id="endTime" required>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="diveSite">Duikplaats:</label>
                <select id="diveSite" required>
            <option value="burgd">Burghsluis</option>
            <option value="cpdl">Colijnsplaat</option>
            <option value="dypc">Dicky’s Place/Gemaal</option>
            <option value="dhdk">Dishoek</option>
            <option value="flauw">Flauwers</option>
            <option value="stvbevp">Goese Sas</option>
            <option value="ghdk">Gorishoek</option>
            <option value="hfwk">Havenhoofd West/Kurkenol</option>
            <option value="irhe">Irenehoeve</option>
            <option value="katsh">Katshoek</option>
            <option value="stvwemew">Kattendijke Parking</option>
            <option value="kstl">Kistersnol</option>
            <option value="lvnsd">Levensstrijd</option>
            <option value="oesp">Oesterputen</option>
            <option value="pltn">Plompe Toren</option>
            <option value="o11">Putti’s Place</option>
            <option value="quack">Quaack/Het oude Dorp</option>
            <option value="stvschk">Schelphoek</option>
            <option value="sphn">Sophiahaven</option>
            <option value="spak">Spyros Amenakis</option>
            <option value="stald">St Annaland</option>
            <option value="ston">Stavenisse Oostnol</option>
            <option value="stsgr">Stavenisse Steiger</option>
            <option value="strd">Strijenham</option>
            <option value="vlie">Vlietepolder</option>
            <option value="vlblt">Vuilnisbelt</option>
            <option value="grb">Wd De Groene Boei</option>
            <option value="dhoek">Wd De Hoek/Galjoen</option>
            <option value="wdoo">Wemeldinge Oost/Linda</option>
            <option value="wkkm">Westkapelle KNRM</option>
            <option value="znp1">Zeelandbrug 1e pijler</option>
            <option value="znp2">Zeelandbrug 2e pijler</option>
            <option value="zpmn">Zijpe (Midden)</option>
            <option value="znsn">Zonneschijn</option>
            <option value="zodk">Zoutelande</option>
            <option value="zubt">Zuidbout</option>
                </select>
            </div>
        </div>
        <button type="submit">Toon stroming</button>
    </form>
    
    <div id="loading-spinner" class="loading-spinner">
        <div class="spinner"></div>
        <div class="loading-text">Stromingsgegevens laden...</div>
    </div>
    
    <div class="legend">
        <h2>Legenda</h2>
        <div><span class="red"></span> Duiken afgeraden (stroming > 30 cm/s)</div>
        <div><span class="orange"></span> Alleen ervaren getijdenduikers (stroming 20-30 cm/s)</div>
        <div><span class="light-green"></span> Alle getijdenduikers (stroming ≤ 20 cm/s)</div>
        <div><span class="dark-green"></span> Stromingskentering (vrijwel geen stroming)</div>
    </div>
    <div id="dive-windows"></div>
    <div id="results"></div>
	<div id="source">De informatie op deze pagina komt van <a href="https://waterberichtgeving.rws.nl/owb/regio/regio-zeeuwse-wateren/duikstekken-zeeland">Rijkswaterstaat Waterberichtgeving</a> en wordt weergegeven zoals deze is, zonder enige garanties.<div>
</body>
</html>
