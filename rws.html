<!-- 
Page to show the current forecast for a dive site in Zeeland, Netherlands.
This page fetches data from the Rijkswaterstaat Waterberichtgeving API and displays it in a table format.
The data includes current speed and direction, with color coding based on the current speed. 

The page also includes a legend to explain the color coding.
The user can select a dive site and specify a time range to get the forecast data.  
The selection of dive sites is based on the available data from the Rijkswaterstaat API.
The dates and times are set to default values of the current date and time, and two days later for the end date and time.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dive Site Data</title>
    <script>
        function setDefaultDateTime() {
            const now = new Date();
            const currentDate = now.toISOString().slice(0, 10);
            const currentTime = now.toTimeString().slice(0, 5);
            document.getElementById('startDate').value = currentDate;
            document.getElementById('startTime').value = currentTime;

            const later = new Date(now.getTime() + 48 * 60 * 60 * 1000);
            const endDate = later.toISOString().slice(0, 10);
            const endTime = later.toTimeString().slice(0, 5);
            document.getElementById('endDate').value = endDate;
            document.getElementById('endTime').value = endTime;
        }
        function getWindDirection(degrees) {
            // Define the wind direction abbreviations and their corresponding ranges
            const directions = [
                { abbr: "N", min: 337.5, max: 360 },
                { abbr: "N", min: 0, max: 22.5 },
                { abbr: "NE", min: 22.5, max: 67.5 },
                { abbr: "E", min: 67.5, max: 112.5 },
                { abbr: "SE", min: 112.5, max: 157.5 },
                { abbr: "S", min: 157.5, max: 202.5 },
                { abbr: "SW", min: 202.5, max: 247.5 },
                { abbr: "W", min: 247.5, max: 292.5 },
                { abbr: "NW", min: 292.5, max: 337.5 }
            ];

            // Normalize degrees to a range of 0 to 360
            degrees = degrees % 360;
            if (degrees < 0) degrees += 360;

            // Find the matching direction
            for (let i = 0; i < directions.length; i++) {
                const dir = directions[i];
                if (degrees >= dir.min && degrees < dir.max) {
                    return dir.abbr;
                }
            }

            // Default to "N" if no match is found (shouldn't happen with current logic)
            return "N";
        }

        async function fetchData() {
            const startDate = document.getElementById('startDate').value;
            const startTime = document.getElementById('startTime').value;
            const endDate = document.getElementById('endDate').value;
            const endTime = document.getElementById('endTime').value;
            const diveSite = document.getElementById('diveSite').value;

            const localStartDateTimeString = `${startDate}T${startTime}:00`;
            const localEndDateTimeString = `${endDate}T${endTime}:00`;

            const StartDateISO = LocalToUTC(localStartDateTimeString);
            const EndDateISO = LocalToUTC(localEndDateTimeString)

//            const url =   `https://waterberichtgeving.rws.nl/wb/data/api/dd/2.0/timeseries?observationTypeId=SG.1&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;
            const url = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?locationCode=${encodeURIComponent(diveSite)}&observationTypeId=SG_SOF_6.1.ms&sourceName=compute&&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&&`;
            const url_w = `https://rwsos.rws.nl/wb-api/dd/2.0/timeseries?observationTypeId=SG.2&sourceName=SOF_6&startTime=${encodeURIComponent(StartDateISO)}&endTime=${encodeURIComponent(EndDateISO)}&locationCode=${encodeURIComponent(diveSite)}`;


            try {
                // get speed information
                const response = await fetch(url);
                const data = await response.json();
                // get direction information
                const response_w = await fetch(url_w);
                const data_w = await response_w.json();
                displayResults(data, data_w);
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        function displayResults(data ,data_w) {
            const diveWindowsContainer = document.getElementById('dive-windows');
            const resultsContainer = document.getElementById('results');
            diveWindowsContainer.innerHTML = '';
            resultsContainer.innerHTML = '';

            if (data.results && data.results.length > 0) {
                const events = data.results[0].events;
                const events_w = data_w.results[0].events;

                // Helper function to calculate minutes between two timestamps
                const getMinutesBetween = (start, end) => {
                    if (!start || !end) return 0;
                    return (new Date(end.timeStamp) - new Date(start.timeStamp)) / (1000 * 60);
                };

                // Add header for dive windows section
                const diveWindowsHeader = document.createElement('h2');
                diveWindowsHeader.textContent = 'Dive windows';
                diveWindowsContainer.appendChild(diveWindowsHeader);

                // Create timeline container
                const timelineContainer = document.createElement('div');
                timelineContainer.className = 'timeline-container';

                // First pass: find all windows and determine the longest duration
                let maxDuration = 0;
                let windows = [];
                let windowStart = null;
                let start20 = null;
                let end20 = null;
                let end30 = null;
                let prevValue = null;

                events.forEach((event, index) => {
                    const value = parseFloat(event.value) * 100; // Convert to cm/s
                    
                    if (prevValue !== null) {
                        // Detect start of window (crossing below 0.3)
                        if (prevValue > 30 && value <= 30) {
                            windowStart = event;
                        }
                        // Detect crossing below 0.2
                        if (prevValue > 20 && value <= 20) {
                            start20 = event;
                        }
                        // Detect crossing above 0.2
                        if (prevValue <= 20 && value > 20) {
                            end20 = events[index - 1];
                        }
                        // Detect crossing above 0.3 (end of window)
                        if (prevValue <= 30 && value > 30) {
                            end30 = events[index - 1];
                            
                            // If we have a complete window, store it
                            if (windowStart) {
                                const duration = getMinutesBetween(windowStart, end30);
                                maxDuration = Math.max(maxDuration, duration);
                                windows.push({
                                    windowStart,
                                    start20,
                                    end20,
                                    end30,
                                    duration
                                });
                            }
                            
                            // Reset for next window
                            windowStart = null;
                            start20 = null;
                            end20 = null;
                            end30 = null;
                        }
                    }
                    prevValue = value;
                });

                // Second pass: create timeline rows with bars scaled to maxDuration
                windows.forEach(window => {
                    const timelineRow = document.createElement('div');
                    timelineRow.className = 'timeline-row';
                    
                    // Add date label
                    const dateLabel = document.createElement('div');
                    dateLabel.className = 'timeline-date';
                    const localTime = UTCToLocal(window.windowStart.timeStamp);
                    const localDateString = localTime.toLocaleString().split(', ')[0];
                    dateLabel.textContent = localDateString;
                    
                    timelineRow.appendChild(dateLabel);

                    // Create container for the bar and labels
                    const timelineBarContainer = document.createElement('div');
                    timelineBarContainer.className = 'timeline-bar-container';

                    // Create timeline bar
                    const timelineBar = document.createElement('div');
                    timelineBar.className = 'timeline-bar';
                    const barWidth = (window.duration / maxDuration) * 800;
                    timelineBar.style.width = `${barWidth}px`;

                    if (window.start20) {
                        // First segment (>20 to ≤30)
                        const segment1 = document.createElement('div');
                        segment1.className = 'timeline-segment speed-30';
                        const width1 = (getMinutesBetween(window.windowStart, window.start20) / window.duration) * 100;
                        segment1.style.width = `${width1}%`;
                        timelineBar.appendChild(segment1);

                        if (window.end20) {
                            // Middle segment (≤20)
                            const segment2 = document.createElement('div');
                            segment2.className = 'timeline-segment speed-20';
                            const width2 = (getMinutesBetween(window.start20, window.end20) / window.duration) * 100;
                            segment2.style.width = `${width2}%`;
                            segment2.style.position = 'relative'; // For absolute positioning of slack indicator
                            
                            // Find slack tide moment within ≤20 period
                            const start20Index = events.findIndex(e => e === window.start20);
                            const end20Index = events.findIndex(e => e === window.end20);
                            if (start20Index !== -1 && end20Index !== -1) {
                                // Find the middle of the green period in time
                                const greenPeriodMinutes = getMinutesBetween(window.start20, window.end20);
                                const midPointMinutes = greenPeriodMinutes / 2;
                                let slackFound = false;
                                let slackTime;
                                let bestSlackIndex = -1;
                                let bestTimeDiff = Infinity;

                                // Search around the middle for the direction change
                                for (let i = start20Index; i < end20Index; i++) {
                                    const currentDir = parseFloat(events_w[i].value);
                                    const nextDir = parseFloat(events_w[i + 1].value);
                                    if ((currentDir > 180 && nextDir < 180) || (currentDir < 180 && nextDir > 180)) {
                                        // Found a direction change
                                        const timeFromStart = getMinutesBetween(window.start20, events[i + 1]);
                                        const timeDiff = Math.abs(timeFromStart - midPointMinutes);
                                        if (timeDiff < bestTimeDiff) {
                                            bestTimeDiff = timeDiff;
                                            bestSlackIndex = i + 1;
                                        }
                                    }
                                }

                                if (bestSlackIndex !== -1) {
                                    slackTime = events[bestSlackIndex];
                                    
                                    // Calculate the relative position of slack time within the green segment
                                    const slackTimeOffset = (getMinutesBetween(window.start20, slackTime) / getMinutesBetween(window.start20, window.end20)) * 100;
                                    
                                    // Create slack indicator
                                    const slackContainer = document.createElement('div');
                                    slackContainer.style.position = 'absolute';
                                    slackContainer.style.left = `${slackTimeOffset}%`;
                                    slackContainer.style.top = '0';
                                    slackContainer.style.height = '100%';
                                    slackContainer.style.transform = 'translateX(-50%)';
                                    slackContainer.style.width = '2px';
                                    slackContainer.style.backgroundColor = '#006600';
                                    slackContainer.style.zIndex = '2';

                                    // Store the slack time, offset, and tide indicator for later use
                                    window.slackTime = slackTime;
                                    window.slackTimeFromStart = getMinutesBetween(window.windowStart, slackTime);
                                    
                                    // Determine tide indicator
                                    const startDirection = parseFloat(events_w[bestSlackIndex - 1].value);
                                    const endDirection = parseFloat(events_w[bestSlackIndex].value);
                                    if (startDirection > 180 && endDirection < 180) {
                                        window.tideIndicator = 'LW';
                                    } else if (startDirection < 180 && endDirection > 180) {
                                        window.tideIndicator = 'HW';
                                    }
                                    
                                    // Add container to segment
                                    segment2.appendChild(slackContainer);
                                }
                            }
                            
                            timelineBar.appendChild(segment2);

                            // Last segment (>20 to ≤30)
                            const segment3 = document.createElement('div');
                            segment3.className = 'timeline-segment speed-30';
                            const width3 = (getMinutesBetween(window.end20, window.end30) / window.duration) * 100;
                            segment3.style.width = `${width3}%`;
                            timelineBar.appendChild(segment3);
                        } else {
                            // Remaining segment (≤20)
                            const segment2 = document.createElement('div');
                            segment2.className = 'timeline-segment speed-20';
                            const width2 = (getMinutesBetween(window.start20, window.end30) / window.duration) * 100;
                            segment2.style.width = `${width2}%`;
                            timelineBar.appendChild(segment2);
                        }
                    } else {
                        // Single segment for entire window (≤30)
                        const segment = document.createElement('div');
                        segment.className = 'timeline-segment speed-30';
                        segment.style.width = '100%';
                        timelineBar.appendChild(segment);
                    }

                    timelineRow.appendChild(timelineBar);

                    // Add time labels
                    const timeLabels = document.createElement('div');
                    timeLabels.className = 'timeline-labels';

                    // Helper function to create positioned label
                    const createLabel = (evt, position) => {
                        if (evt) {
                            const label = document.createElement('span');
                            label.textContent = UTCToLocal(evt.timeStamp).toLocaleString().split(', ')[1].substring(0,5);
                            label.style.left = `${position}px`;
                            label.className = 'start';
                            timeLabels.appendChild(label);
                        }
                    };

                    // Calculate pixel positions for labels based on the actual bar width
                    let currentPosition = 0;
                    
                    // Start of window (<=0.3)
                    createLabel(window.windowStart, 0);

                    if (window.start20) {
                        // Time when <=0.2 starts
                        const start20Pixels = (getMinutesBetween(window.windowStart, window.start20) / window.duration) * barWidth;
                        createLabel(window.start20, start20Pixels);

                        if (window.end20) {
                            // Time when >0.2 starts
                            const end20Pixels = (getMinutesBetween(window.windowStart, window.end20) / window.duration) * barWidth;
                            createLabel(window.end20, end20Pixels);
                        }
                    }

                    // End of window (>0.3)
                    createLabel(window.end30, barWidth);

                    // Add slack time label if it exists
                    if (window.slackTime) {
                        const slackLabelPosition = (window.slackTimeFromStart / window.duration) * barWidth;
                        
                        // Create container for slack time and tide indicator
                        const slackContainer = document.createElement('div');
                        slackContainer.className = 'slack-container';
                        slackContainer.style.left = `${slackLabelPosition}px`;
                        
                        // Add tide indicator if it exists
                        if (window.tideIndicator) {
                            const tideLabel = document.createElement('div');
                            tideLabel.textContent = window.tideIndicator;
                            tideLabel.className = 'tide-indicator';
                            slackContainer.appendChild(tideLabel);
                        }
                        
                        // Add slack time
                        const slackLabel = document.createElement('div');
                        slackLabel.textContent = UTCToLocal(window.slackTime.timeStamp).toLocaleString().split(', ')[1].substring(0,5);
                        slackLabel.className = 'slack-time';
                        slackContainer.appendChild(slackLabel);
                        
                        timeLabels.appendChild(slackContainer);
                        
                        // Clean up
                        delete window.slackTime;
                        delete window.slackTimeFromStart;
                        delete window.tideIndicator;
                    }

                    timelineBarContainer.appendChild(timelineBar);
                    timelineBarContainer.appendChild(timeLabels);
                    timelineRow.appendChild(timelineBarContainer);
                    
                    timelineContainer.appendChild(timelineRow);
                });

                timelineContainer.style.marginBottom = "20px";
                diveWindowsContainer.appendChild(timelineContainer);

                // Add header for current details section
                const currentDetailsHeader = document.createElement('h2');
                currentDetailsHeader.textContent = 'Current details';
                resultsContainer.appendChild(currentDetailsHeader);

                // Create main table
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const tbody = document.createElement('tbody');

                // Create table headers
                const headerRow = document.createElement('tr');
                const dateHeader = document.createElement('th');
                dateHeader.textContent = 'Date';
                const timeHeader = document.createElement('th');
                timeHeader.textContent = 'Time';
                const valueHeader = document.createElement('th');
                valueHeader.textContent = 'Current (cm/s)';
                const DirectionHeader = document.createElement('th');
                DirectionHeader.textContent = 'Direction';

                headerRow.appendChild(dateHeader);
                headerRow.appendChild(timeHeader);
                headerRow.appendChild(valueHeader);
                headerRow.appendChild(DirectionHeader);
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Find the lowest values in each sequence of values below 20
                let lowestValue = null;
                let lowestValueIndex = -1;

                events.forEach((event, index) => {
                    const value = parseFloat(event.value);
                    if (value < 20) {
                        if (lowestValue === null || value < lowestValue) {
                            lowestValue = value;
                            lowestValueIndex = index;
                        }
                    } else {
                        if (lowestValue !== null) {
                            events[lowestValueIndex].isLowest = true;
                        }
                        lowestValue = null;
                        lowestValueIndex = -1;
                    }
                });

                // Check the last sequence
                if (lowestValue !== null) {
                    events[lowestValueIndex].isLowest = true;
                }

                // Populate table rows
                var i = -1;
                events.forEach(event => {
                    i++;
                    if (!event.value) {
                        return;
                    }
                    const row = document.createElement('tr');
                    const dateCell = document.createElement('td');
                    const timeCell = document.createElement('td');
                    const valueCell = document.createElement('td');
                    const directionCell = document.createElement('td');

                    // Split the timestamp into date and time parts
					const localTime = UTCToLocal(event.timeStamp);
                    const localDateTimeString = localTime.toLocaleString();
                    const localDateString = localDateTimeString.split(', ')[0];
                    const localTimeString = localDateTimeString.split(', ')[1].substring(0,5);
                    
                    Date().toLocaleString
                    dateCell.textContent = localDateString;
                    timeCell.textContent = localTimeString;
                    valueCell.textContent = Math.round(event.value * 100);
                    directionCell.textContent = events_w[i].value + " (" +  getWindDirection(events_w[i].value) + ")";

                    // Apply background color based on value
                    const value = parseFloat(event.value);
                    if (event.isLowest) {
                        row.style.backgroundColor = '#99ff99'; // darker green
                    } else if (value > 0.30) {
                        row.style.backgroundColor = '#ffcccc'; // light pastel red
                    } else if (value > 0.20) {
                        row.style.backgroundColor = '#ffe6cc'; // light pastel orange
                    } else {
                        row.style.backgroundColor = '#ccffcc'; // light pastel green
                    }
                    row.appendChild(dateCell);
                    row.appendChild(timeCell);
                    row.appendChild(valueCell);
                    row.appendChild(directionCell);
                    tbody.appendChild(row);
                });

                table.appendChild(tbody);
                resultsContainer.appendChild(table);
            } else {
                resultsContainer.textContent = 'No results found.';
            }
        }
        
        function UTCToLocal(utcstring) {
            utcISOString = utcstring.replace(':00Z',':00.000Z');
            var strUTC = ( new Date(utcISOString) ).toISOString();
            var datetimeLocal = new Date( strUTC );

            return datetimeLocal; 
        }


        function LocalToUTC(localstring) {

            var strUTC = ( new Date(localstring) ).toISOString();
            strUTCFormatted = strUTC.replace(':00.000Z',':00Z');
            return strUTCFormatted; 
            
        }
        
        window.onload = setDefaultDateTime;
    </script>
    <style>
		body {
			font-family: Arial, Helvetica, "Liberation Sans", sans-serif;
		}
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
            text-align: left;
        }
                h2 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        /* Styles for the timeline */
        .timeline-container {
            width: 100%;
            padding: 20px 0;
        }
        .timeline-row {
            display: flex;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
        }
        .timeline-date {
            width: 100px;
            flex-shrink: 0;
        }
        .timeline-bar {
            width: 800px; /* Base width for the longest duration */
            height: 30px;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
            margin-right: 20px;
            border: 1px solid #ddd;
            flex-shrink: 1;
        }
        .timeline-segment {
            height: 100%;
            transition: width 0.3s ease;
        }
        .timeline-segment.speed-30 {
            background-color: #ffcccc;
        }
        .timeline-segment.speed-20 {
            background-color: #ccffcc;
        }
        .timeline-labels {
            position: absolute;
            display: flex;
            top: -35px;
            width: 100%;
            pointer-events: none;
        }
        .timeline-labels span {
            font-size: 0.9em;
            position: absolute;
            white-space: nowrap;
            top: 15px;
            transform: translateX(-50%);
        }
        .timeline-bar-container {
            position: relative;
        }
        .slack-container {
            position: absolute;
            transform: translateX(-50%);
            text-align: center;
            min-width: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .tide-indicator {
            color: #006600;
            font-weight: bold;
            margin-bottom: 2px;
            font-size: 0.8em;
            white-space: nowrap;
        }
        .slack-time {
            color: #006600;
            font-weight: bold;
            background-color: #ffffff;
            padding: 0 4px;
            white-space: nowrap;
        }
        .timeline-row {
            position: relative;
            padding-top: 25px;
        }
        /* Styles for the main table */
        #results table {
            margin-bottom: 30px;
            width: 100%;
        }
        #results td {
            text-align: center;
        }
        .legend {
            margin-top: 20px;
        }
        .legend div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend span {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }
        .legend .red {
            background-color: #ffcccc;
        }
        .legend .orange {
            background-color: #ffe6cc;
        }
        .legend .light-green {
            background-color: #ccffcc;
        }
        .legend .dark-green {
            background-color: #99ff99;
        }
		#source {
			position: fixed;
			bottom: 0;
			left: 0;
			width: 100%;
			background-color: #f0f0f0; /* optional background color */
			padding: 10px;
			text-align: center;
			font-size: 12px; /* adjust the font size as needed */
			border-top: 1px solid #ccc; /* optional border at the top */
		}
    </style>
</head>
<body>
    <h1>Dive site current forecast</h1>
    <form onsubmit="event.preventDefault(); fetchData();">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" required>
        <label for="startTime">Start Time:</label>
        <input type="time" id="startTime" required>
        <br>
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" required>
        <label for="endTime">End Time:</label>
        <input type="time" id="endTime" required>
        <br>
        <label for="diveSite">Dive Site:</label>
        <select id="diveSite" required>
            <option value="burgd">Burghsluis</option>
            <option value="cpdl">Colijnsplaat</option>
            <option value="dypc">Dicky’s Place/Gemaal</option>
            <option value="dhdk">Dishoek</option>
            <option value="flauw">Flauwers</option>
            <option value="stvbevp">Goese Sas</option>
            <option value="ghdk">Gorishoek</option>
            <option value="hfwk">Havenhoofd West/Kurkenol</option>
            <option value="irhe">Irenehoeve</option>
            <option value="katsh">Katshoek</option>
            <option value="stvwemew">Kattendijke Parking</option>
            <option value="kstl">Kistersnol</option>
            <option value="lvnsd">Levensstrijd</option>
            <option value="oesp">Oesterputen</option>
            <option value="pltn">Plompe Toren</option>
            <option value="o11">Putti’s Place</option>
            <option value="quack">Quaack/Het oude Dorp</option>
            <option value="stvschk">Schelphoek</option>
            <option value="sphn">Sophiahaven</option>
            <option value="spak">Spyros Amenakis</option>
            <option value="stald">St Annaland</option>
            <option value="ston">Stavenisse Oostnol</option>
            <option value="stsgr">Stavenisse Steiger</option>
            <option value="strd">Strijenham</option>
            <option value="vlie">Vlietepolder</option>
            <option value="vlblt">Vuilnisbelt</option>
            <option value="grb">Wd De Groene Boei</option>
            <option value="dhoek">Wd De Hoek/Galjoen</option>
            <option value="wdoo">Wemeldinge Oost/Linda</option>
            <option value="wkkm">Westkapelle KNRM</option>
            <option value="znp1">Zeelandbrug 1e pijler</option>
            <option value="znp2">Zeelandbrug 2e pijler</option>
            <option value="zpmn">Zijpe (Midden)</option>
            <option value="znsn">Zonneschijn</option>
            <option value="zodk">Zoutelande</option>
            <option value="zubt">Zuidbout</option>
        </select>
        <br>
        <button type="submit">Get Data</button>
    </form>
    <div class="legend">
        <h2>Legend</h2>
        <div><span class="red"></span> Diving not advised (current > 30 cm/s)</div>
        <div><span class="orange"></span> Only experienced tidal divers (current 20-30 cm/s)</div>
        <div><span class="light-green"></span> All tidal divers (current ≤ 20 cm/s)</div>
        <div><span class="dark-green"></span> Moment of slack tide (hardly any current)</div>
    </div>
    <div id="dive-windows"></div>
    <div id="results"></div>
	<div id="source">Information on this page is retrieved from <a href="https://waterberichtgeving.rws.nl/owb/regio/regio-zeeuwse-wateren/duikstekken-zeeland">Rijkswaterstaat Waterberichtgeving</a> and displayed as is, without any warrantees.<div>
</body>
</html>
